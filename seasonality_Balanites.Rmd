---
title: "seasonality_Balanites"
author: "Natalia_MEDINA"
date: "`r Sys.Date()`"
output:
  word_document: default
  html_document: default
  pdf_document: default
  always_allow_html: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(latexpdf)
library(tinytex)
```

# Data packages, import and preparation

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r Packages}

#all the packages that are going to be necessary: 
library(purrr)

library(iNEXT)#for the diversity index
library (vegan)
library (glmmTMB)#for the models in order to take generalized poisson if needed (more recommended than poisson)
library(ggplot2)#boxplot
library(rlang)
library(stringr)
library(ggpubr)
library(DHARMa)

library(fitdistrplus)
library(MASS)

#network

library("bipartite")
library(tidyverse)
library(viridis)
library(patchwork)
library(hrbrthemes)
library(circlize)
library(magrittr)
library(networkD3)

library(dplyr)
vapply(c("magrittr","stringr", "glmmTMB", "readr", "janitor", "scales", "mgcv", "RColorBrewer", "dplyr","ggplot2","car","reshape","tidyverse", "lme4", "contrast","vegan", "iNEXT","grid","gridExtra","VennDiagram","emmeans", "DHARMa", "MuMIn", "ape", "pander","factoextra","FactoMineR","gdm","betapart", "cowplot"), library, logical(1L),
       character.only = TRUE, logical.return = TRUE)
citation(package = "lme4")


library(webshot2)
library(webshot2)
library(pheatmap)
library(hrbrthemes)
library(plotly)


library(ggrepel)



#add all the packages needed here


```

```{r Data import}
#From the abundance initial data filled from de insect determination: 


#Import data
Ferlo <- read.csv('Base_primaire1.csv', sep = ';')#ici toute la matrice d'abondances avec les informations correspondantes
Order_info <- read.csv('taxo.csv', sep = ';')  #ici le dataframe avec les ordres et familles 
data_ind_K<- read.csv('data_ind_Koyli.csv', sep = ';', dec = ",")#data floraison et densité arbres autour


##here import all the data needed 

```

```{r Data preparation}


#data frame preparation
## Here make all the matrix needed:

# List of column names
Headers <- names(Ferlo)
print(Headers)

#print (Headers)
Col0 <- 16  # Column where morpho-species start (so this one need to be modified if necessary)


## this reunites the abundance base_primaire matrix into one data.frame
##it is possible to separate from the beginning Balanites and Vachellia 
## the last part bring together the information for the dataframe taxo and All to be able to have one big database with all the information centralized in all_data


#cont_Bal <- 0  # Counter for Balanites
#cont_Vac <- 0  # Counter for Vachellia
cont <- 0

for (i in Col0:length(Headers)) {#do not forget to modified Col0 depending in the number of columns where "morphospecies" starts
  
  Who_nan <- is.na(Ferlo[[Headers[i]]])
  All_Spe <- which(!Who_nan)
  
  for (j in seq_along(All_Spe)) {
    Whe <- All_Spe[j]
    
    # Information in dataframe
    s1 <- data.frame(
      morphospecies = Headers[i],
      Locality = Ferlo$Localite[Whe],
      id_tree = Ferlo$identifiant_tree[Whe],
      Methode = Ferlo$Methode[Whe],
      moment= Ferlo$moment[Whe],
      season=Ferlo$saison[Whe],
      ID=Ferlo$ID[Whe],
      ID_t = Ferlo$ID_arbre[Whe],
      datasite = Ferlo$datasite[Whe],
      site_date = Ferlo$sitedate[Whe],
      id_site= Ferlo$Idsite[Whe],
      site= Ferlo$site[Whe],
      species_tree=Ferlo$espece_arbre[Whe],
      ID_date = Ferlo$individu_date[Whe],
      date = Ferlo$date[Whe],
      Abun_tree = Ferlo[[Headers[i]]][Whe]
    )
    
    Info_Head <- c("morphospecies","Locality","id_tree","Methode", "moment", "season","ID","ID_t" ,
                   "datasite", "site_date","id_site", "site", "species_tree", "ID_date", "date",
                   "Abun_tree") #Here import all the information containing in the initial data
    
    species_tree <- Ferlo$espece_arbre[Whe]
    if (cont == 0) {
      All <- s1
    } else {
      All <- bind_rows(All, s1)
    }
    cont <<- cont + 1
  }
}

all_data1 <- left_join(Order_info,All,by="morphospecies", multiple = "all") #all_data1 bind with other infos related to the morphospecies (in Order_family a lot of empty spaces)
#write.csv(all_data, 'data_frame_All.csv', row.names = FALSE)#vérifier quelques details sur 86 dans tableau primaire, être sure que toutes les familles se retrouvent et les vides les effacer par la suite

all_data1$morphospecies <- all_data1$morphospecies %>% str_to_lower()
all_data<-all_data1[all_data1$Order != "Arachnida",]



### season lists 
dfs_lists_VB <- list() #creation of a list where is in going to be possible to find all the different subsets of interest

for (tree_species in unique(all_data$species_tree)) {
  
  # Filter data for the current locality and tree species
  subset_data <- filter(all_data, species_tree == tree_species)
  
  # Check if there are rows in the subset
  if (nrow(subset_data) > 0) {
    
    # Create a unique identifier for the combination
    identifier <- paste0(tree_species)
    
    # Extract specific columns
    subset_data <- subset_data %>%
      select(morphospecies,
             Order,
             Family, Superfamily, functional_group, guild,
             Locality,id_tree,Methode, moment, season, ID, ID_t,
             datasite, site_date,id_site, site, ID_date, date,
             Abun_tree) #faire le choix des informations à faire apparaitre 
    
    # Assign the subset to a dataframe with a unique name
    dfs_lists_VB[[identifier]] <- subset_data
  }
}

#For this paper I will only take into account the information in Balanites , and only for one location Koyli_Alpha


```

# All seasons and all methods related analysis in Koyli Alpha:

```{r Data subset for all insects all methods}
#######in Koyli Alpha selection depending on the method

#All 

subset_data_K_all <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha")
desired_order<-c("J","A","F")
subset_data_K_all$season <- factor(subset_data_K_all$season, levels = desired_order)

abundance_aggregated_all<-aggregate(Abun_tree ~ morphospecies+Methode+season+id_tree+site, data = subset_data_K_all, sum)

abundance_aggregated_all<-aggregate(Abun_tree ~ morphospecies+Methode+season+functional_group+Order+Family+id_tree+site, data = subset_data_K_all, sum)


abundance_aggregated_a<- left_join(data_ind_K,abundance_aggregated_all,by="id_tree", multiple = "all")

desired_order<-c("J","A","F")
abundance_aggregated_a$season <- factor(abundance_aggregated_a$season, levels = desired_order)


abundance_aggregated_graph1<-aggregate(Abun_tree ~ Order, data = subset_data_K_all, sum)

abundance_aggregated_graph2<-aggregate(Abun_tree ~ Family, data = subset_data_K_all, sum)
```

```{r Data subset for every order - all methods}

abundance_aggregated_graphHymeno<-subset_data_K_all%>%  filter(Order %in% ("Hymenoptera"))

abundance_graphHymeno<-aggregate(Abun_tree ~ Family+Superfamily+morphospecies+functional_group, data = abundance_aggregated_graphHymeno, sum)

abundance_hymeno<-aggregate(Abun_tree ~ Family+Superfamily+morphospecies+functional_group, data = subset_data_K_all%>% filter(Order %in% ("Hymenoptera")), sum)

abundance_dipte<-aggregate(Abun_tree ~ Family+Superfamily+morphospecies+functional_group, data = subset_data_K_all%>% filter(Order %in% ("Diptera")), sum)

abundance_coleo<-aggregate(Abun_tree ~ Family+Superfamily+morphospecies+functional_group, data = subset_data_K_all%>% filter(Order %in% ("Coleoptera")), sum)

abundance_thysa<-aggregate(Abun_tree ~ Family+Superfamily+morphospecies+functional_group, data = subset_data_K_all%>% filter(Order %in% ("Thysanoptera")), sum)

abundance_hemip<-aggregate(Abun_tree ~ Family+Superfamily+morphospecies+functional_group+season, data = subset_data_K_all%>% filter(Order %in% ("Hemiptera")), sum)

abundance_other<-subset_data_K_all %>%
  filter(!(Order %in% c("Diptera", "Hymenoptera", "Coleoptera", "Thysanoptera", "Insecta", "Hemiptera", "Lepidoptera"))) %>%
  aggregate(Abun_tree ~ Family + Superfamily + morphospecies + functional_group, data = ., sum)


```

Data for all treatments - unrestored, restored and unrestored depression :

```{r Data Abundance matrix per treatment}
###creation de matrice pour toutes les informations comprises 

# first one with the treatments

UniMorpho <- unique(abundance_aggregated_a$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_a$site)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_a$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K <- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K) <- UniMorpho
colnames(Abu_K) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_a$site == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_a$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_a$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K[i, j] <- Abui
  }
}
```

```{r graphs/treatments}

### Indices de diversité de Chao
ChaoRichness(Abu_K)#avec des dataframe, faire en fonction de ce que je cherche, par exemple tel que c'est fait, methode, site, localité, saison
ChaoShannon(Abu_K)
DataInfo(Abu_K)

data_info <- DataInfo(Abu_K)
# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = n, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = n), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the abundance per treatment - Koyli Alpha",
       x = "Treatment",
       y = "Total abundance") +
  theme_minimal()


data_info <- ChaoRichness(Abu_K)
data_info$Assemblage<-rownames(data_info)
# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = Observed, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Observed), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the species richness per treatment  - Koyli Alpha",
       x = "Treatment",
       y = "Species richness") +
  theme_minimal()

#q =c(0,1,2) pour les indices de Hill

nex<-iNEXT(Abu_K, q=0, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex, type=1)

df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn0<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values= c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+scale_fill_manual(values=c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+
  labs(x="Abundance", y="Species richness - q = 0") +
  ggtitle("Koyli Alpha - all")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 





nex2<-iNEXT(Abu_K, q=2, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex2, type=1)
df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn2<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values= c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+scale_fill_manual(values=c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+
  labs(x="Abundance", y="Simpson diversity - q=2") +
  ggtitle("Koyli Alpha - all")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 

ekn0#courbe de rarefaction (changer le nombre de Hill si nécessaire)
ekn2#courbe de rarefaction (changer le nombre de Hill si nécessaire)



```

```{r Total abundance plots}
###Matrix per season

UniMorpho <- unique(abundance_aggregated_a$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_a$season)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_a$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_s <- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_s) <- UniMorpho
colnames(Abu_K_s) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_a$season == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_a$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_a$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_s[i, j] <- Abui
  }
}
desired_order<-c("J","A","F")



```

```{r graphs/seasons}
##### Indices de diversité de Chao
ChaoRichness(Abu_K_s)#avec des dataframe, faire en fonction de ce que je cherche, par exemple tel que c'est fait, methode, site, localité, saison
ChaoShannon(Abu_K_s)
DataInfo(Abu_K_s)


data_info <- DataInfo(Abu_K_s)
data_info$Assemblage<-factor((data_info$Assemblage), levels = desired_order)
# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = n, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = n), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the abundance per season -all sampling methods ",
       x = "Season",
       y = "Total abundance") +
  theme_minimal()



data_info <- ChaoRichness(Abu_K_s)
data_info$Assemblage<-rownames(data_info)

data_info$Assemblage<-factor(rownames(data_info), levels = desired_order)

# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = Observed, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Observed), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the species richness per season - all sampling methods",
       x = "Season",
       y = "Species richness") +
  theme_minimal()



#q =c(0,1,2) pour les indices de Hill

nex<-iNEXT(Abu_K_s, q=0, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex, type=1)

df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn0<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values=c("#1F78B4", "#33A02C", "#E31A1C"))+scale_fill_manual(values=c("#1F78B4", "#33A02C", "#E31A1C"))+
  labs(x="Abundance", y="Species richness - q=0") +
  ggtitle("Koyli Alpha - all")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 





nex2<-iNEXT(Abu_K_s, q=2, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex2, type=1)
df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn2<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values=c("#1F78B4", "#33A02C", "#E31A1C"))+scale_fill_manual(values=c("#1F78B4", "#33A02C", "#E31A1C"))+
  labs(x="Abundance", y="Simpson diversity - q = 2") +
  ggtitle("Koyli Alpha - all")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 

ekn0#courbe de rarefaction (changer le nombre de Hill si nécessaire)
ekn2#courbe de rarefaction (changer le nombre de Hill si nécessaire)




```

```{r Total abundance glmm}
subset_data_K_n <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha" )



abundance_aggregated_g<-aggregate(Abun_tree ~morphospecies+guild+Family+functional_group+Order+ site+season, data = subset_data_K_n, sum)#this will be modified depending on the specific guild or order studied 





###glmm model


candidate_models_Abun2<- list(
glmbn4=glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn41=glmer.nb(Abun_tree ~ site+guild+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn42=glmer.nb(Abun_tree ~ site+guild+functional_group+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn5=glmer.nb(Abun_tree ~ season+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn51=glmer.nb(Abun_tree ~ season+guild+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn52=glmer.nb(Abun_tree ~ season+Order+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")))

candidate_models_Abun2


aic_data <- data.frame(Model = character(), AIC = numeric())

# Calculate AIC for each model
for (model_name in names(candidate_models_Abun2)) {
  model <- candidate_models_Abun2[[model_name]]
  aic <- AIC(model)
  aic_data <- rbind(aic_data, data.frame(Model = model_name, AIC = aic))
}

 aic_data


# Control argument specifies the way we optimize the
# parameter values

glmbn4=glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))

glmbn41=glmer.nb(Abun_tree ~ site+guild+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))

glmbn42=glmer.nb(Abun_tree ~ site+guild+functional_group+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))



glmbn5=glmer.nb(Abun_tree ~ season+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))

glmbn51=glmer.nb(Abun_tree ~ season+guild+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))


glmbn53=glm.nb(Abun_tree ~ season+Family, data = abundance_aggregated_g)

glmbn54=glm.nb(Abun_tree ~ season+Order, data = abundance_aggregated_g)

glmbn52=glmer.nb(Abun_tree ~ season+Order+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))

#Estimation des paramètres du modèle par l'approximation de Laplace(Bolker, 2008) -> trop de facteurs aléatoires nécessaires au calcul du modèle pour faire une quadrature de Gausse-Hermite (impossible pour la fonction si plus de 1 et en général si + de 2,3)

summary(glmbn4)
summary(glmbn41)
summary(glmbn42)
summary(glmbn5)
summary(glmbn51)
summary(glmbn52)
summary(glmbn53)
summary(glmbn54)

Anova(glmbn4, type=3, method="chisq") 
Anova(glmbn41, type=3, method="chisq")
Anova(glmbn42, type=3, method="chisq")

Anova(glmbn5, type=3, method="chisq") #methode chis2 car glmer et type 3 car plan déséuilibré
Anova(glmbn51, type=3, method="chisq")
Anova(glmbn52, type=3, method="chisq")
Anova(glmbn53, type=3, method="chisq")


#Test des résidus
library(DHARMa)


plot(simulateResiduals(glmbn4))
plot(simulateResiduals(glmbn42))

plot(simulateResiduals(glmbn5))
plot(simulateResiduals(glmbn51))
plot(simulateResiduals(glmbn52))
plot(simulateResiduals(glmbn53))
plot(simulateResiduals(glmbn54))

library(MuMIn) #Détermination du r2

r.squaredGLMM(glmbn4)
r.squaredGLMM(glmbn42)
r.squaredGLMM(glmbn5)
r.squaredGLMM(glmbn52)
r.squaredGLMM(glmbn53)

#R2m représente le r avec seulement les effets fixes, et r2c il y a les effets de groupes
#trigamma la plus fiabl




emtb1 <- lsmeans(glmbn4, ~ site)
pairs(emtb1)

emtb11 <- lsmeans(glmbn42, ~ site)
pairs(emtb11)

emtb2 <- lsmeans(glmbn5, ~ season) #changer l'écriture de la formule
pairs(emtb2)

emtb21 <- lsmeans(glmbn51, ~ guild) #changer l'écriture de la formule
pairs(emtb21)
emtb22 <- lsmeans(glmbn52, ~ Order) #changer l'écriture de la formule
pairs(emtb22)



```

# Net related analysis

All net related analysis and graphs can be found in this part the most important is to consider the detail of each subset (by order, family, functional group)

```{r Net data subset}
#######in Koyli Alpha selection depending on the method

#All 

subset_data_K_n <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net" )


#abundance_aggregated_fl<- left_join(data_ind_K,subset_data_K_n,by="id_tree", multiple = "all")
abundance_aggregated_n<-aggregate(Abun_tree ~ morphospecies+id_tree+site+season, data = subset_data_K_n, sum)#this will be modified depending on the specific guild or order studied 


#abundance_aggregated_n$flowering <- scale(abundance_aggregated$flowering)#rescale the flowering index


```

```{r Net data matrix/season}

###Matrix per season 

UniMorpho <- unique(abundance_aggregated_n$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_n$season)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_n$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_N <- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_N) <- UniMorpho
colnames(Abu_K_N) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_n$season == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_n$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_n$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_N[i, j] <- Abui
  }
}
desired_order<-c("J","A","F")


```

```{r Net graphs/seasons}


#### Indices de diversité de Chao
ChaoRichness(Abu_K_N)#avec des dataframe, faire en fonction de ce que je cherche, par exemple tel que c'est fait, methode, site, localité, saison
ChaoShannon(Abu_K_N)
DataInfo(Abu_K_N)


data_info <- DataInfo(Abu_K_N)

data_info$Assemblage<-factor((data_info$Assemblage), levels = desired_order)
# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = n, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = n), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the abundance per season - Net sampling",
       x = "Season",
       y = "Total abundance") +
  theme_minimal()



data_info <- ChaoRichness(Abu_K_N)
data_info$Assemblage<-factor(rownames(data_info), levels = desired_order)

# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = Observed, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Observed), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the species richness per season - Net sampling",
       x = "Season",
       y = "Species richness") +
  theme_minimal()


###par saison Net
NEXKN<-data.frame(Abu_K_N)
Ju<-nrow(subset(NEXKN, NEXKN$J>0))
Au<-nrow(subset(NEXKN, NEXKN$A>0))
Fe<-nrow(subset(NEXKN, NEXKN$F>0))

JA<-nrow(subset(NEXKN, NEXKN$J>0 & NEXKN$A>0))
JF<-nrow(subset(NEXKN, NEXKN$J>0 & NEXKN$F>0)) 
FA<-nrow(subset(NEXKN, NEXKN$F>0 & NEXKN$A>0)) 
JAF<-nrow(subset(NEXKN, NEXKN$J>0 & NEXKN$A>0 & NEXKN$F>0))


grid.newpage()
draw.triple.venn(area1 = Ju, area2 = Au , area3 = Fe, n12 = JA, n23 = FA, n13 = JF, 
                 n123 = JAF, category = c("June", "August", "February"), lty = "blank", 
                 fill = c("#1F78B4", "#33A02C", "#E31A1C"))



#q =c(0,1,2) pour les indices de Hill

nex<-iNEXT(Abu_K_N, q=0, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex, type=1)

df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn0<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values=c("#1F78B4", "#33A02C", "#E31A1C"))+scale_fill_manual(values=c("#1F78B4", "#33A02C", "#E31A1C"))+
  labs(x="Abundance", y="Species richness - q=0") +
  ggtitle("Net - Koyli Alpha")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 





nex2<-iNEXT(Abu_K_N, q=2, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex2, type=1)
df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn2<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values=c("#1F78B4", "#33A02C", "#E31A1C"))+scale_fill_manual(values=c("#1F78B4", "#33A02C", "#E31A1C"))+
  labs(x="Abundance", y="Simpson diversity - q=2") + #for simpson 
  ggtitle("Net - Koyli Alpha")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 

ekn0#courbe de rarefaction (changer le nombre de Hill si nécessaire)
ekn2#courbe de rarefaction (changer le nombre de Hill si nécessaire)



```

```{r Net data matrix/treatments}

###Matrix per treatment

UniMorpho <- unique(abundance_aggregated_n$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_n$site)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_n$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_nt<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_nt) <- UniMorpho
colnames(Abu_K_nt) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_n$site == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_n$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_n$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_nt[i, j] <- Abui
  }
}

```

```{r Net graphs/treatments}


##### Indices de diversité de Chao
ChaoRichness(Abu_K_nt)#avec des dataframe, faire en fonction de ce que je cherche, par exemple tel que c'est fait, methode, site, localité, saison
ChaoShannon(Abu_K_nt)
DataInfo(Abu_K_nt)


data_info <- DataInfo(Abu_K_nt)
# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = n, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = n), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the abundance in per treatment - Koyli Alpha ",
       x = "Site",
       y = "Total abundance") +
  theme_minimal()



data_info <- ChaoRichness(Abu_K_nt)
data_info$Assemblage<-rownames(data_info)

# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = Observed, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Observed), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the species richness per treatment - Koyli Alpha/Net",
       x = "Site",
       y = "Species richness") +
  theme_minimal()


###par saison Net
NEXKNt<-data.frame(Abu_K_nt)
Un<-nrow(subset(NEXKNt, NEXKNt$Unrestored>0))
Und<-nrow(subset(NEXKNt, NEXKNt$Depression>0))
Res<-nrow(subset(NEXKNt, NEXKNt$Restored>0))

UUD<-nrow(subset(NEXKNt, NEXKNt$Unrestored>0 & NEXKNt$Depression>0))
UR<-nrow(subset(NEXKNt, NEXKNt$Unrestored>0 & NEXKNt$Restored>0)) 
RUD<-nrow(subset(NEXKNt, NEXKNt$Depression>0 & NEXKNt$Restored>0)) 
UUDR<-nrow(subset(NEXKNt, NEXKNt$Unrestoresd>0 & NEXKNt$Depression>0 & NEXKNt$Restored>0))


grid.newpage()
draw.triple.venn(area1 = Un, area2 = Und , area3 = Res, n12 = UUD, n23 = RUD, n13 =UR , 
                 n123 = UUDR, category = c("Unrestored", "Unrestored depression", "Restored"), lty = "blank", 
                 fill = c("#FF5722", "#CDDC39", "#26A69A"))

## color code per sitec(rep("#26A69A",1), rep("#CDDC39",1), rep("#FF5722",1))


#q =c(0,1,2) pour les indices de Hill

nex<-iNEXT(Abu_K_nt, q=0, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex, type=1)

df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn0<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values= c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+scale_fill_manual(values=c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+
  labs(x="Abundance", y="Species richness - q=1") +
  ggtitle("Net - Koyli Alpha")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 


ekn0#courbe de rarefaction (changer le nombre de Hill si nécessaire)


nex2<-iNEXT(Abu_K_nt, q=2, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)


df <- fortify(nex2, type=1)
df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn2<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values= c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+scale_fill_manual(values=c(Unrestored = "#FF5722", Depression = "#CDDC39", Restored = "#26A69A"))+
  labs(x="Abundance", y="Simpson diversity - q=2") +
  ggtitle("Net - Koyli Alpha")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 


ekn2#courbe de rarefaction (changer le nombre de Hill si nécessaire)



```

## Net glmm Models

```{r Net glmm models -net }


#Net 

subset_data_K_n <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net" )



subset_data_ind_k<- left_join(data_ind_K,subset_data_K_n,by="id_tree", multiple = "all")

abundance_aggregated_g<-aggregate(Abun_tree ~id_tree+ site+season+flowering+mean_dist+tree_richness+min_dist, data = subset_data_ind_k, sum)#this will be modified depending on the specific guild or order studied 




#abundance_aggregated_g<-aggregate(Abun_tree ~id_tree+ site+season+flowering+mean_dist+tree_richness+min_dist, data = subset_data_ind_k, sum)

desired_order <- c("J", "A", "F") 
abundance_aggregated_g$season<- factor(abundance_aggregated_g$season, levels = desired_order)


ggplot(abundance_aggregated_g) +
  aes(x = Abun_tree, y = season, fill = season) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Set1", direction = 1) +
  scale_x_continuous(trans = "log10") +
  coord_flip() +
  theme_minimal()+
  theme(
    axis.text.y = element_text(size = 13L),
    axis.text.x = element_text(size = 13L)
  ) 

###glmm model


candidate_models_Abun1<- list(
glmbn4=glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn41=glmer.nb(Abun_tree ~ site+flowering+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn42=glmer.nb(Abun_tree ~ site+flowering+tree_richness+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn43=glmer.nb(Abun_tree ~ site+flowering+tree_richness+mean_dist+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn5=glmer.nb(Abun_tree ~ season+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn51=glmer.nb(Abun_tree ~ flowering+season+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn52=glmer.nb(Abun_tree ~ flowering+season+tree_richness+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn53=glmer.nb(Abun_tree ~ flowering+season+tree_richness+mean_dist+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")))

candidate_models_Abun1


aic_data <- data.frame(Model = character(), AIC = numeric())

# Calculate AIC for each model
for (model_name in names(candidate_models_Abun1)) {
  model <- candidate_models_Abun1[[model_name]]
  aic <- AIC(model)
  aic_data <- rbind(aic_data, data.frame(Model = model_name, AIC = aic))
}

 aic_data


# Control argument specifies the way we optimize the
# parameter values

glmbn4=glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))


glmbn5=glmer.nb(Abun_tree ~ season+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))
summary(glmbn5)





glmbn42=glmer.nb(Abun_tree ~ site+flowering+tree_richness+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))
glmbn52=glmer.nb(Abun_tree ~ flowering+season+tree_richness+(1|site), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))
#Estimation des paramètres du modèle par l'approximation de Laplace(Bolker, 2008) -> trop de facteurs aléatoires nécessaires au calcul du modèle pour faire une quadrature de Gausse-Hermite (impossible pour la fonction si plus de 1 et en général si + de 2,3)


summary(glmbn4)
summary(glmbn42)
summary(glmbn5)




Anova(glmbn4, type=3, method="chisq") 
Anova(glmbn42, type=3, method="chisq")

Anova(glmbn5, type=3, method="chisq") #methode chis2 car glmer et type 3 car plan déséuilibré




#Test des résidus
library(DHARMa)


plot(simulateResiduals(glmbn4))
plot(simulateResiduals(glmbn42))

plot(simulateResiduals(glmbn5))




library(MuMIn) #Détermination du r2

r.squaredGLMM(glmbn4)
r.squaredGLMM(glmbn42)
r.squaredGLMM(glmbn5)



#R2m représente le r avec seulement les effets fixes, et r2c il y a les effets de groupes
#trigamma la plus fiabl




emtb1 <- lsmeans(glmbn4, ~ site)
pairs(emtb1)

emtb11 <- lsmeans(glmbn42, ~ site)
pairs(emtb11)

emtb2 <- lsmeans(glmbn5, ~ season) #changer l'écriture de la formule
pairs(emtb2)






model2ab <- lm(log1p(Abun_tree) ~ season, data = abundance_aggregated_g)
summary(model2ab)

plot(simulateResiduals(model2ab))
Anova(model2ab, type=3, method="chisq")


glmbn5_simplified <- glm.nb(Abun_tree ~ season, data = abundance_aggregated_g)
summary(glmbn5_simplified)
r.squaredGLMM(glmbn5_simplified)
Anova(glmbn5_simplified, type=3, method="chisq")
plot(simulateResiduals(glmbn5_simplified))
emtb22 <- lsmeans(glmbn5_simplified, ~ season) #changer l'écriture de la formule
pairs(emtb22)

```

```{r Net data abundance matrix/id_tree }



###Matrix per treatment

UniMorpho <- unique(subset_data_ind_k$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(subset_data_ind_k$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(subset_data_ind_k$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_tn<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_tn) <- UniMorpho
colnames(Abu_K_tn) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- subset_data_ind_k$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- subset_data_ind_k$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(subset_data_ind_k$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_tn[i, j] <- Abui
  }
}


ChaoRichness(Abu_K_tn)#avec des dataframe, faire en fonction de ce que je cherche, par exemple tel que c'est fait, methode, site, localité, saison

ChaoShannon(Abu_K_tn)

DataInfo(Abu_K_tn)



#Diversity index - q=0,1,2 - Species richness, Shannon, Simpson

q0_result <- iNEXT(Abu_K_tn, q = 0, datatype = "abundance")

q2_result <- iNEXT(Abu_K_tn, q = 2, datatype = "abundance")
q1_result <- iNEXT(Abu_K_tn, q = 1, datatype = "abundance")


q2_result[["AsyEst"]]$id_tree<-q2_result[["AsyEst"]]$Assemblage
q1_result[["AsyEst"]]$id_tree<-q2_result[["AsyEst"]]$Assemblage
q0_result[["AsyEst"]]$id_tree<-q2_result[["AsyEst"]]$Assemblage



dataq2 <- subset(q2_result[["AsyEst"]],
                        Diversity == "Simpson diversity")
dataq0 <- subset(q0_result[["AsyEst"]],
                        Diversity == "Species richness")

dataq1 <- subset(q1_result[["AsyEst"]],
                        Diversity == "Shannon diversity")



```

```{r Net glmm models simpson }

#faire une transformation log + 1 s'il y a des valeurs en 0 et tester gaussian distribution

#simpson diversity dataq2$Observed

### i have removed the glmer gamma
subset_data_ndiversity1<- left_join(dataq1,subset_data_ind_k,by="id_tree", multiple = "all")
abundance_aggregated_g1 <- unique(subset_data_ndiversity1[, c("id_tree", "site", "season", "flowering", "mean_dist", "tree_richness", "min_dist", "Observed")])

subset_data_ndiversity0<- left_join(dataq0,subset_data_ind_k,by="id_tree", multiple = "all")
abundance_aggregated_g0 <- unique(subset_data_ndiversity0[, c("id_tree", "site", "season", "flowering", "mean_dist", "tree_richness", "min_dist", "Observed")])
desired_order <- c("J", "A", "F") 
abundance_aggregated_g0$season<- factor(abundance_aggregated_g0$season, levels = desired_order)

ggplot(abundance_aggregated_g0) +
  aes(x = Observed, y = season, fill = season) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Set1", direction = 1) +
  coord_flip() +
  theme_minimal()+
  theme(
    axis.text.y = element_text(size = 13L),
    axis.text.x = element_text(size = 13L)
  ) 

subset_data_ndiversity2<- left_join(dataq2,subset_data_ind_k,by="id_tree", multiple = "all")
abundance_aggregated_g2 <- unique(subset_data_ndiversity2[, c("id_tree", "site", "season", "flowering", "mean_dist", "tree_richness", "min_dist", "Observed")])

 
# Replacement for modelsea0
modelsea0 <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g0)


# Replacement for modelsea1
modelsea1 <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g1)

# Replacement for modelsea2
modelsea2 <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g2)




modelsit0 <- lmer(log1p(Observed) ~ site + (1|season),
              data = abundance_aggregated_g0)
modelsit1 <- lmer(log1p(Observed) ~ site + (1|season),
              data = abundance_aggregated_g1)

modelsit2 <- lmer(log1p(Observed) ~ site + (1|season),
              data = abundance_aggregated_g2)


# View the results

summary(modelsea0)

summary(modelsea1)

summary(modelsea2)

summary(modelsit0)

summary(modelsit1)

summary(modelsit2)

# Convert season to factor for all datasets
abundance_aggregated_g0$season <- factor(abundance_aggregated_g0$season)
abundance_aggregated_g1$season <- factor(abundance_aggregated_g1$season)
abundance_aggregated_g2$season <- factor(abundance_aggregated_g2$season)

# Relevel season to use 'F' as the reference level
abundance_aggregated_g0$season <- relevel(abundance_aggregated_g0$season, ref = "F")
abundance_aggregated_g1$season <- relevel(abundance_aggregated_g1$season, ref = "F")
abundance_aggregated_g2$season <- relevel(abundance_aggregated_g2$season, ref = "F")

# Replacement for modelsea0 with releveling
modelsea0_replacement <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g0)
summary(modelsea0_replacement)

modelsea1_replacement <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g1)
summary(modelsea1_replacement)

modelsea2_replacement <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g2)
summary(modelsea2_replacement)

Anova(modelsea1, type=3, method="chisq")

Anova(modelsea0, type=3, method="chisq")

Anova(modelsea2, type=3, method="chisq")

Anova(modelsit1, type=3, method="chisq")

Anova(modelsit2, type=3, method="chisq")

Anova(modelsit0, type=3, method="chisq")

library(DHARMa)



plot(simulateResiduals(modelsea1))
 
plot(simulateResiduals(modelsea0))
 
plot(simulateResiduals(modelsea2))
 
plot(simulateResiduals(modelsit1))
 
#plot(simulateResiduals(modelsit0))
plot(simulateResiduals(modelsit2))
 
library(MuMIn) #Détermination du r2

r.squaredGLMM(modelsit1)

r.squaredGLMM(modelsit2)




emtb1 <- lsmeans(modelsit1, ~ site)
pairs(emtb1)



emtb2 <- lsmeans(modelsit2, ~ site)
pairs(emtb2)



```

```{r Net glmm models species richness}

subset_data_ndiversity<- left_join(dataq0,subset_data_ind_k,by="id_tree", multiple = "all")

abundance_aggregated_g <- unique(subset_data_ndiversity[, c("id_tree", "site", "season", "flowering", "mean_dist", "tree_richness", "Observed")])


###glmm model

candidate_models_sper1<- list(
glmbn4=glmer.nb(Observed ~ site+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn41=glmer.nb(Observed ~ site+flowering+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn42=glmer.nb(Observed ~ site+flowering+tree_richness+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa")),

glmbn43=glmer.nb(Observed ~ site+flowering+tree_richness+mean_dist+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))

)

candidate_models_sper1


aic_data <- data.frame(Model = character(), AIC = numeric())

# Calculate AIC for each model
for (model_name in names(candidate_models_sper1)) {
  model <- candidate_models_sper1[[model_name]]
  aic <- AIC(model)
  aic_data <- rbind(aic_data, data.frame(Model = model_name, AIC = aic))
}

 aic_data


# Control argument specifies the way we optimize the
# parameter values


glmbn4=glmer.nb(Observed ~ site+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))

glmbn41=glmer.nb(Observed ~ site+flowering+(1|season), data = abundance_aggregated_g, control = glmerControl(optimizer = "bobyqa"))

#Estimation des paramètres du modèle par l'approximation de Laplace(Bolker, 2008) -> trop de facteurs aléatoires nécessaires au calcul du modèle pour faire une quadrature de Gausse-Hermite (impossible pour la fonction si plus de 1 et en général si + de 2,3)

summary(glmbn4)
summary(glmbn41)


Anova(glmbn4, type=3, method="chisq") 
Anova(glmbn41, type=3, method="chisq")





#Test des résidus
library(DHARMa)


plot(simulateResiduals(glmbn4))
plot(simulateResiduals(glmbn41))



library(MuMIn) #Détermination du r2

r.squaredGLMM(glmbn4)
r.squaredGLMM(glmbn41)

#R2m représente le r avec seulement les effets fixes, et r2c il y a les effets de groupes
#trigamma la plus fiabl




emtb1 <- lsmeans(glmbn4, ~ site)
pairs(emtb1)

emtb11 <- lsmeans(glmbn41, ~ site, by = "flowering")
pairs(emtb11)




#residuals <- residuals(glmbn4)

# Create diagnostic plots
#plot_residuals <- data.frame(
#   Fitted = fitted(glmbn4),
#  Residuals = residuals
#)

# Residual vs. Fitted plot
#ggplot(plot_residuals, aes(x = Fitted, y = Residuals)) +
 # geom_point() +
  #geom_hline(yintercept = 0, linetype = "dashed") +
  #labs(x = "Fitted values", y = "Residuals") +
  #ggtitle("Residuals vs. Fitted")

# QQ plot
#qqnorm(residuals)
#qqline(residuals)

# Scale-Location plot
#ggplot(plot_residuals, aes(x = Fitted, y = abs(sqrt(abs(Residuals))))) +
#  geom_point() +
#  geom_smooth(method = "loess", se = FALSE) +
#  labs(x = "Fitted values", y = "Square root of standardized residuals") +
#  ggtitle("Scale-Location plot")



```

```{r Net glmm models net hymenoptera }


#Net 

subset_data_K_nH <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net" & Order == "Hymenoptera")



subset_data_ind_kH<- left_join(data_ind_K,subset_data_K_nH,by="id_tree", multiple = "all")

#abundance_aggregated_gH<-aggregate(Abun_tree ~id_tree+ site+season+flowering+mean_dist+tree_richness+min_dist+Family, data = subset_data_ind_kH, sum)#this will be modified depending on the specific guild or order studied 


abundance_aggregated_gH<-aggregate(Abun_tree ~id_tree+season+site+flowering+Family+tree_richness+mean_dist, data = subset_data_ind_kH, sum)

desired_order <- c("J", "A", "F") 
abundance_aggregated_gH$season<- factor(abundance_aggregated_gH$season, levels = desired_order)


###glmm model


candidate_models_Abun1<- list(
glmbn4=glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa")),

glmbn41=glmer.nb(Abun_tree ~ site+flowering+(1|season), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa")),

glmbn42=glmer.nb(Abun_tree ~ site+flowering+tree_richness+(1|season), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa")),

glmbn43=glmer.nb(Abun_tree ~ site+flowering+tree_richness+mean_dist+(1|season), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa")),

glmbn5=glmer.nb(Abun_tree ~ season+(1|site), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa")),

glmbn51=glmer.nb(Abun_tree ~ flowering+season+(1|site), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa")),

glmbn52=glmer.nb(Abun_tree ~ flowering+season+tree_richness+(1|site), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa")),

glmbn53=glmer.nb(Abun_tree ~ flowering+season+tree_richness+mean_dist+(1|site), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa")))

candidate_models_Abun1


aic_data <- data.frame(Model = character(), AIC = numeric())

# Calculate AIC for each model
for (model_name in names(candidate_models_Abun1)) {
  model <- candidate_models_Abun1[[model_name]]
  aic <- AIC(model)
  aic_data <- rbind(aic_data, data.frame(Model = model_name, AIC = aic))
}

 aic_data


# Control argument specifies the way we optimize the
# parameter values

glmbn4=glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa"))


glmbn5=glmer.nb(Abun_tree ~ season+(1|site), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa"))
summary(glmbn5)





glmbn42=glmer.nb(Abun_tree ~ site+flowering+tree_richness+(1|season), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa"))
glmbn52=glmer.nb(Abun_tree ~ flowering+season+tree_richness+(1|site), data = abundance_aggregated_gH, control = glmerControl(optimizer = "bobyqa"))
#Estimation des paramètres du modèle par l'approximation de Laplace(Bolker, 2008) -> trop de facteurs aléatoires nécessaires au calcul du modèle pour faire une quadrature de Gausse-Hermite (impossible pour la fonction si plus de 1 et en général si + de 2,3)


summary(glmbn4)
summary(glmbn42)
summary(glmbn5)




Anova(glmbn4, type=3, method="chisq") 
Anova(glmbn42, type=3, method="chisq")

Anova(glmbn5, type=3, method="chisq") #methode chis2 car glmer et type 3 car plan déséuilibré




#Test des résidus
library(DHARMa)


plot(simulateResiduals(glmbn4))
plot(simulateResiduals(glmbn42))

plot(simulateResiduals(glmbn5))




library(MuMIn) #Détermination du r2

r.squaredGLMM(glmbn4)
r.squaredGLMM(glmbn42)
r.squaredGLMM(glmbn5)



#R2m représente le r avec seulement les effets fixes, et r2c il y a les effets de groupes
#trigamma la plus fiabl




emtb1 <- lsmeans(glmbn4, ~ site)
pairs(emtb1)

emtb11 <- lsmeans(glmbn42, ~ site)
pairs(emtb11)

emtb2 <- lsmeans(glmbn5, ~ season) #changer l'écriture de la formule
pairs(emtb2)






model2ab <- lm(log1p(Abun_tree) ~ season, data = abundance_aggregated_gH)
summary(model2ab)

plot(simulateResiduals(model2ab))
Anova(model2ab, type=3, method="chisq")







library(car)
library(emmeans)
library(DHARMa)

glmbn5_simplified <- glm.nb(Abun_tree ~season, data = abundance_aggregated_gH)
summary(glmbn5_simplified)
Anova(glmbn5_simplified, type=3, method="chisq")
r.squaredGLMM(glmbn5_simplified)
plot(simulateResiduals(glmbn5_simplified))
emtb22 <- lsmeans(glmbn5_simplified, ~ season) #changer l'écriture de la formule
pairs(emtb22)

```

```{r Net glmm models -net boucle seasons}

# Function to perform analysis for a given superfamily
analyze_superfamily <- function(superfamily) {
  # Subset the data
  subset_data <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Net" & Superfamily == superfamily)
  
  # Aggregate the data
  abundance_aggregated <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_data, sum)
  
  # Ensure the 'season' factor is ordered
  desired_order <- c("J", "A", "F") 
  abundance_aggregated$season <- factor(abundance_aggregated$season, levels = desired_order)
  
  # Fit the negative binomial model
  glmbn <- glm.nb(Abun_tree ~ season, data = abundance_aggregated)
  
  # Model summary and ANOVA
  model_summary <- summary(glmbn)
  model_anova <- Anova(glmbn, type = 3, method = "chisq")
  
  # Plot residuals
  residuals_plot <- plot(simulateResiduals(glmbn))
  
  # Post-hoc tests
  emtb <- emmeans(glmbn, ~ season)
  pairwise_comparisons <- pairs(emtb)
  
  # Return results
  list(
    summary = model_summary,
    anova = model_anova,
    residuals_plot = residuals_plot,
    emtb = emtb,
    pairwise_comparisons = pairwise_comparisons
  )
}

# List of superfamilies to analyze
superfamilies <- c("Formicoidea", "Apoidea") # Add more superfamilies as needed



# Analyze each superfamily
results <- lapply(superfamilies, analyze_superfamily)
results


# Function to perform analysis for a given superfamily
analyze_superfamilyp <- function(superfamily) {
  # Subset the data
  subset_data <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Pantrap" & Superfamily == superfamily)
  
  # Aggregate the data
  abundance_aggregated <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_data, sum)
  
  # Ensure the 'season' factor is ordered
  desired_order <- c("J", "A", "F") 
  abundance_aggregated$season <- factor(abundance_aggregated$season, levels = desired_order)
  
  # Fit the negative binomial model
  glmbn <- glm.nb(Abun_tree ~ season, data = abundance_aggregated)
  
  # Model summary and ANOVA
  model_summary <- summary(glmbn)
  model_anova <- Anova(glmbn, type = 3, method = "chisq")
  
  # Plot residuals
  residuals_plot <- plot(simulateResiduals(glmbn))
  
  # Post-hoc tests
  emtb <- emmeans(glmbn, ~ season)
  pairwise_comparisons <- pairs(emtb)
  
  # Return results
  list(
    summary = model_summary,
    anova = model_anova,
    residuals_plot = residuals_plot,
    emtb = emtb,
    pairwise_comparisons = pairwise_comparisons
  )
}

# List of superfamilies to analyze
superfamilies <- c("Formicoidea", "Apoidea") # Add more superfamilies as needed



# Analyze each superfamily
resultsp <- lapply(superfamilies, analyze_superfamilyp)
resultsp




# Function to perform analysis for a given superfamily
analyze_order <- function(order) {
  # Subset the data
  subset_data <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Methode == "Net" & Order == order)
  
  # Aggregate the data
  abundance_aggregated <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_data, sum)
  
  # Ensure the 'season' factor is ordered
  desired_order <- c("J", "A", "F") 
  abundance_aggregated$season <- factor(abundance_aggregated$season, levels = desired_order)
  
  # Fit the negative binomial model
  glmbn <- glm.nb(Abun_tree ~ season, data = abundance_aggregated)
  
  # Model summary and ANOVA
  model_summary <- summary(glmbn)
  model_anova <- Anova(glmbn, type = 3, method = "chisq")
  
  # Plot residuals
  residuals_plot <- plot(simulateResiduals(glmbn))
  
  # Post-hoc tests
  emtb <- emmeans(glmbn, ~ season)
  pairwise_comparisons <- pairs(emtb)
  
  # Return results
  list(
    summary = model_summary,
    anova = model_anova,
    residuals_plot = residuals_plot,
    emtb = emtb,
    pairwise_comparisons = pairwise_comparisons
  )
}

# List of superfamilies to analyze
orders <- c("Hymenoptera", "Diptera", "Coleoptera", "Hemiptera") # Add more superfamilies as needed



# Analyze each superfamily
results_order <- lapply(orders, analyze_order)
results_order





# Function to perform analysis for a given superfamily
analyze_orderp <- function(order) {
  # Subset the data
  subset_data <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Methode == "Pantrap" & Order == order)
  
  # Aggregate the data
  abundance_aggregated <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_data, sum)
  
  # Ensure the 'season' factor is ordered
  desired_order <- c("J", "A", "F") 
  abundance_aggregated$season <- factor(abundance_aggregated$season, levels = desired_order)
  
  # Fit the negative binomial model
  glmbn <- glm.nb(Abun_tree ~ season, data = abundance_aggregated)
  
  # Model summary and ANOVA
  model_summary <- summary(glmbn)
  model_anova <- Anova(glmbn, type = 3, method = "chisq")
  
  # Plot residuals
  residuals_plot <- plot(simulateResiduals(glmbn))
  
  # Post-hoc tests
  emtb <- emmeans(glmbn, ~ season)
  pairwise_comparisons <- pairs(emtb)
  
  # Return results
  list(
    summary = model_summary,
    anova = model_anova,
    residuals_plot = residuals_plot,
    emtb = emtb,
    pairwise_comparisons = pairwise_comparisons
  )
}

# List of superfamilies to analyze
orders <- c("Hymenoptera", "Diptera", "Coleoptera", "Hemiptera") # Add more superfamilies as needed



# Analyze each superfamily
results_orderp <- lapply(orders, analyze_orderp)
results_orderp



```

```{r Net data abundance matrix/id_tree - Hymenoptera }
#sans les effets autres que fleurs et/arbre
#abundance_aggregated_gH<-aggregate(Abun_tree ~id_tree+ site+season, data = subset_data_K_nH, sum)#this will be modified depending on the specific guild or order studied
#desired_order <- c("J", "A", "F") 
#abundance_aggregated_gH$season<- factor(abundance_aggregated_gH$season, levels = desired_order)

###Matrix per treatment

UniMorpho <- unique(subset_data_K_nH$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(subset_data_K_nH$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(subset_data_K_nH$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_tnH<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_tnH) <- UniMorpho
colnames(Abu_K_tnH) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- subset_data_K_nH$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- subset_data_K_nH$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(subset_data_K_nH$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_tnH[i, j] <- Abui
  }
}


ChaoRichness(Abu_K_tnH)#avec des dataframe, faire en fonction de ce que je cherche, par exemple tel que c'est fait, methode, site, localité, saison
ChaoShannon(Abu_K_tnH)
DataInfo(Abu_K_tnH)



#data_info <- DataInfo(Abu_K_tn)
# Plot bar chart for 'n' and 'S.obs'
#ggplot(data_info, aes(x = Assemblage, y = n, fill = Assemblage)) +
#  theme_bw() +
#  geom_bar(stat = "identity", position = "dodge") +
#  labs(title = "Bar Plot for the abundance per id_tree - Koyli Alpha",
#       x= "Tree ID",      
#       y = "Total abundance") +
#  theme_minimal()


#data_info <- ChaoRichness(Abu_K_tn)
#data_info$id_tree<-rownames(data_info)
# Plot bar chart for 'n' and 'S.obs'
#ggplot(data_info, aes(x = id_tree, y = Observed, fill = id_tree)) +
#  theme_bw() +
#  geom_bar(stat = "identity", position = "dodge") +
#    labs(title = "Bar Plot for the species richness per treatment  - Koyli Alpha",
#          x= "Tree ID",     
#         y = "Species richness") +
#  theme_minimal()


#Diversity index - q=0,1,2 - Species richness, Shannon, Simpson

q0_result <- iNEXT(Abu_K_tnH, q = 0, datatype = "abundance")
q0_result[["AsyEst"]]$id_tree<-q2_result[["AsyEst"]]$Assemblage



dataq0 <- subset(q0_result[["AsyEst"]],
                        Diversity == "Species richness")


```

```{r Net glmm models simpson - Hymenoptera}
#faire une transformation log + 1 s'il y a des valeurs en 0 et tester gaussian distribution

#simpson diversity dataq2$Observed


### i have removed the glmer gamma
 


subset_data_ndiversity0H<- left_join(dataq0,subset_data_K_nH,by="id_tree", multiple = "all")
desired_order <- c("J", "A", "F")
subset_data_ndiversity0H$season<- factor(subset_data_ndiversity0H$season, levels = desired_order)

abundance_aggregated_g0H <- unique(subset_data_ndiversity0H[, c("id_tree", "site", "season", "Observed")])

desired_order <- c("J", "A", "F") 
abundance_aggregated_g0H$season<- factor(abundance_aggregated_g0H$season, levels = desired_order)
abundance_aggregated_g0H

# Replacement for modelsea0
modelsea0H <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g0H)


modelsit0H <- lmer(log1p(Observed) ~ site + (1|season),
              data = abundance_aggregated_g0H)


summary(modelsea0H)
summary(modelsit0H)



# Convert season to factor for all datasets
abundance_aggregated_g0H$season <- factor(abundance_aggregated_g0H$season)

# Relevel season to use 'F' as the reference level
abundance_aggregated_g0H$season <- relevel(abundance_aggregated_g0H$season, ref = "F")

# Replacement for modelsea0 with releveling
modelsea0H_replacement <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g0H)
summary(modelsea0H_replacement)




Anova(modelsea0H, type=3, method="chisq")
Anova(modelsea0H_replacement, type=3, method="chisq")
Anova(modelsit0H, type=3, method="chisq")

#Test des résidus
library(DHARMa)



plot(simulateResiduals(modelsea0H))



library(MuMIn) #Détermination du r2



#R2m représente le r avec seulement les effets fixes, et r2c il y a les effets de groupes
#trigamma la plus fiabl






emtb0 <- lsmeans(modelsit0H, ~ site)
#pairs(emtb0)









```

```{r Net glmm models -net sites - boucle }


# Function to perform analysis for a given superfamily
analyze_superfamily <- function(superfamily) {
  # Subset the data
  subset_data <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Net" & Superfamily == superfamily)
  
  # Aggregate the data
  abundance_aggregated <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_data, sum)
  

  # Fit the negative binomial model
   glmbn <- glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated, control = glmerControl(optimizer = "bobyqa"))
  
  # Model summary and ANOVA
  model_summary <- summary(glmbn)
  model_anova <- Anova(glmbn, type = 3, method = "chisq")
  
  # Plot residuals
  residuals_plot <- plot(simulateResiduals(glmbn))
  
  # Post-hoc tests
  emtb <- emmeans(glmbn, ~ site)
  pairwise_comparisons <- pairs(emtb)
  
  # Return results
  list(
    summary = model_summary,
    anova = model_anova,
    residuals_plot = residuals_plot,
    emtb = emtb,
    pairwise_comparisons = pairwise_comparisons
  )
}

# List of superfamilies to analyze
superfamilies <- c("Formicoidea", "Apoidea") # Add more superfamilies as needed



# Analyze each superfamily
results <- lapply(superfamilies, analyze_superfamily)
results


# Function to perform analysis for a given superfamily
analyze_superfamilyp <- function(superfamily) {
  # Subset the data
  subset_data <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Pantrap" & Superfamily == superfamily)
  
  # Aggregate the data
  abundance_aggregated <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_data, sum)

  
  # Fit the negative binomial model
  glmbn <- glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated, control = glmerControl(optimizer = "bobyqa"))
  
  # Model summary and ANOVA
  model_summary <- summary(glmbn)
  model_anova <- Anova(glmbn, type = 3, method = "chisq")
  
  # Plot residuals
  residuals_plot <- plot(simulateResiduals(glmbn))
  
  # Post-hoc tests
  emtb <- emmeans(glmbn, ~ site)
  pairwise_comparisons <- pairs(emtb)
  
  # Return results
  list(
    summary = model_summary,
    anova = model_anova,
    residuals_plot = residuals_plot,
    emtb = emtb,
    pairwise_comparisons = pairwise_comparisons
  )
}

# List of superfamilies to analyze
superfamilies <- c("Formicoidea", "Apoidea") # Add more superfamilies as needed



# Analyze each superfamily
resultsp <- lapply(superfamilies, analyze_superfamilyp)
resultsp




# Function to perform analysis for a given superfamily
analyze_order <- function(order) {
  # Subset the data
  subset_data <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Methode == "Net" & Order == order)
  
  # Aggregate the data
  abundance_aggregated <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_data, sum)
  

  # Fit the negative binomial model
   glmbn <- glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated, control = glmerControl(optimizer = "bobyqa"))
  
  # Model summary and ANOVA
  model_summary <- summary(glmbn)
  model_anova <- Anova(glmbn, type = 3, method = "chisq")
  
  # Plot residuals
  residuals_plot <- plot(simulateResiduals(glmbn))
  
  # Post-hoc tests
  emtb <- emmeans(glmbn, ~ site)
  pairwise_comparisons <- pairs(emtb)
  
  # Return results
  list(
    summary = model_summary,
    anova = model_anova,
    residuals_plot = residuals_plot,
    emtb = emtb,
    pairwise_comparisons = pairwise_comparisons
  )
}

# List of superfamilies to analyze
orders <- c("Hymenoptera", "Diptera", "Coleoptera", "Hemiptera") # Add more superfamilies as needed



# Analyze each superfamily
results_order <- lapply(orders, analyze_order)
results_order





# Function to perform analysis for a given superfamily
analyze_orderp <- function(order) {
  # Subset the data
  subset_data <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Methode == "Pantrap" & Order == order)
  
  # Aggregate the data
  abundance_aggregated <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_data, sum)
 
  # Fit the negative binomial model
  #glmbn <- glm.nb(Abun_tree ~ site, data = abundance_aggregated)
   glmbn <- glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated, control = glmerControl(optimizer = "bobyqa"))
  
  # Model summary and ANOVA
  model_summary <- summary(glmbn)
  model_anova <- Anova(glmbn, type = 3, method = "chisq")
  
  # Plot residuals
  residuals_plot <- plot(simulateResiduals(glmbn))
  
  # Post-hoc tests
  emtb <- emmeans(glmbn, ~ site)
  pairwise_comparisons <- pairs(emtb)
  
  # Return results
  list(
    summary = model_summary,
    anova = model_anova,
    residuals_plot = residuals_plot,
    emtb = emtb,
    pairwise_comparisons = pairwise_comparisons
  )
}

# List of superfamilies to analyze
orders <- c("Hymenoptera", "Diptera", "Coleoptera", "Hemiptera") # Add more superfamilies as needed



# Analyze each superfamily
results_orderp <- lapply(orders, analyze_orderp)
results_orderp



```

## CCA in Net sampling

```{r net cca treatment - by site and seasons}
#data preparation - subset of the data of interest

subset_data_K_p_netw<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                              moment == "jour"& Locality == "Koyli_Alpha" & Methode == "Net" & Order != "Lepidoptera")

#abundance_aggregated_fl<- left_join(data_ind_K,subset_data_K_n,by="id_tree", multiple = "all")
abundance_aggregated_netw<-aggregate(Abun_tree ~ morphospecies+id_tree+site+season+Family+Order+functional_group, data = subset_data_K_p_netw, sum)#this will be modified depending on the specific guild or order studied 



##with this line change the degree of filtering (by order, functional group or other interesting question that needs to be explore)
abundance_aggregated_netw<-abundance_aggregated_netw %>%  filter(Order %in% c("Hymenoptera", "Diptera"))

###Matrix 

UniMorpho <- unique(abundance_aggregated_netw$Family)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_netw$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_netw$Family), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_N_fam <- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_N_fam) <- UniMorpho
colnames(Abu_K_N_fam) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_netw$id_tree== uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_netw$Family == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_netw$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_N_fam[i, j] <- Abui
  }
}

transposed_matrix_n_id<-t(Abu_K_N_fam)


##preparation dataset for cca
#for abundance 
species_data<-transposed_matrix_n_id
species_data<-as.data.frame(species_data)

# Create a dataframe from the matrix
my_data_species <- as.data.frame(species_data, row.names = NULL)
my_data_species$id_tree <- rownames(species_data)
# Reset row names of the dataframe
rownames(my_data_species) <- NULL

#for presence /absence 
species_presence_absence <- ifelse(species_data > 0, 1, 0)
#Create a dataframe from the matrix
my_data_species <- as.data.frame(species_presence_absence, row.names = NULL)
my_data_species$id_tree <- rownames(species_presence_absence)
# Reset row names of the dataframe
rownames(my_data_species) <- NULL



#preparing environmental data
subset_data_cca <- unique(abundance_aggregated_netw[, c("id_tree","site", "season")])
rownames(subset_data_cca) <- subset_data_cca$id_tree
subset_data_cca$id_tree <- NULL


#cca model and test assumptions

env_data<-subset_data_cca
desired_order<-c("J","A","F")
env_data$season <- factor(env_data$season, levels = desired_order)

```

```{r net cca models - by site and seasons}

#presence/absence cca
cca_result <- cca(species_presence_absence, env_data)
cca_result2<-cca(species_presence_absence~season + Condition(site), data= env_data)
cca_result3<-cca(species_presence_absence~site + Condition(season), data= env_data)



anova(cca_result, permutations = 199)
anova(cca_result2, permutations = 199)
anova(cca_result3, permutations = 199)


#summary(cca_result2)
#summary(cca_result3)

#abundance cca
cca_model<-cca(species_data, env_data)
cca_model2<-cca(species_data~season + Condition(site), data= env_data)
cca_model3<-cca(species_data~site + Condition(season), data= env_data)


anova(cca_model, permutations = 199)
anova(cca_model2, permutations = 199)
anova(cca_model3, permutations = 199)

anova (cca_model2, by = "mar", permutations = 199)
anova (cca_model3, by = "ter", permutations = 199)
anova (cca_model3, by = "axis", permutations = 199)




###cca plot with ggplot
plot(cca_model3)
plot(cca_model2)

summary(cca_model3)
summary(cca_model2)


#plot for cca_model2

# Extract site and species scores
site_scores <- scores(cca_model2, display = "sites")
site_scores_df <- as.data.frame(site_scores)
site_scores_df$site <- env_data$site
site_scores_df$season <- env_data$season

# Convert scores to data frames
species_scores <- scores(cca_model2, display = "species")
species_scores_df <- as.data.frame(species_scores)
species_scores_df$species <- rownames(species_scores_df)

# Add site and season information to site_scores_df


# Define a color vector for sites using a palette
site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Set1")
names(site_col_vector) <- c("J", "A", "F")

# Define a color vector for sites using a palette
#site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Dark2") 
#names(site_col_vector) <- c("Depression","Unrestored","Restored")


# Create the ggplot
p1 <- ggplot() +
  geom_point(data = site_scores_df, aes(x = CCA1, y = CCA2, color = season, fill = season), shape = 21, size = 3) +
  scale_color_manual(values = site_col_vector) +
  scale_fill_manual(values = site_col_vector) +
  theme_minimal() +
  labs(title = "CCA Plot", x = "CCA1", y = "CCA2") +
  stat_ellipse(data = site_scores_df, aes(x = CCA1, y = CCA2, group = season), color = "black", size = 0.8)+
  geom_text_repel(data = species_scores_df, aes(x = CCA1, y = CCA2, label = species), color = "black", size = 3,  max.overlaps = Inf)

# Print the plot
p1

#plot for cca_model3

# Assuming your CCA model is named cca_model2
# Extract scores for sites and species
site_scores <- scores(cca_model3, display = "sites")
# Convert to data frames for ggplot2
site_scores_df <- as.data.frame(site_scores)
site_scores_df$site <- env_data$site
site_scores_df$season <- env_data$season


species_scores <- scores(cca_model3, display = "species")
species_scores_df <- as.data.frame(species_scores)
species_scores_df$species <- rownames(species_scores_df)

# Define a color vector for sites using a palette
site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Dark2") 
names(site_col_vector) <- c("Depression","Unrestored","Restored")


# Create the ggplot
p2<- ggplot() +
  geom_point(data = site_scores_df, aes(x = CCA1, y = CCA2, color = site, fill = site), shape = 21, size = 3) +
  scale_color_manual(values = site_col_vector) +
  scale_fill_manual(values = site_col_vector) +
  theme_minimal() +
  labs(title = "CCA Plot", x = "CCA1", y = "CCA2") +
  stat_ellipse(data = site_scores_df, aes(x = CCA1, y = CCA2, group = site), color = "black", size = 0.8) +
  geom_text_repel(data = species_scores_df, aes(x = CCA1, y = CCA2, label = species), color = "black", size = 3,  max.overlaps = Inf)
p2


#cca_result2


# Extract site and species scores
site_scores <- scores(cca_result2, display = "sites")
site_scores_df <- as.data.frame(site_scores)
site_scores_df$site <- env_data$site
site_scores_df$season <- env_data$season

# Convert scores to data frames
species_scores <- scores(cca_result2, display = "species")
species_scores_df <- as.data.frame(species_scores)
species_scores_df$species <- rownames(species_scores_df)

# Add site and season information to site_scores_df


# Define a color vector for sites using a palette
site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Set1")
names(site_col_vector) <- c("J", "A", "F")

# Define a color vector for sites using a palette
#site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Dark2") 
#names(site_col_vector) <- c("Depression","Unrestored","Restored")


# Create the ggplot
r1 <- ggplot() +
  geom_point(data = site_scores_df, aes(x = CCA1, y = CCA2, color = season, fill = season), shape = 21, size = 3) +
  scale_color_manual(values = site_col_vector) +
  scale_fill_manual(values = site_col_vector) +
  theme_minimal() +
  labs(title = "CCA Plot", x = "CCA1", y = "CCA2") +
  stat_ellipse(data = site_scores_df, aes(x = CCA1, y = CCA2, group = season), color = "black", size = 0.8)+
  geom_text_repel(data = species_scores_df, aes(x = CCA1, y = CCA2, label = species), color = "black", size = 3,  max.overlaps = Inf)

# Print the plot
r1


#cca_result3
# Assuming your CCA model is named cca_model2
# Extract scores for sites and species
site_scores <- scores(cca_result3, display = "sites")
# Convert to data frames for ggplot2
site_scores_df <- as.data.frame(site_scores)
site_scores_df$site <- env_data$site
site_scores_df$season <- env_data$season


species_scores <- scores(cca_result3, display = "species")
species_scores_df <- as.data.frame(species_scores)
species_scores_df$species <- rownames(species_scores_df)

# Define a color vector for sites using a palette
site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Dark2") 
names(site_col_vector) <- c("Depression","Unrestored","Restored")


# Create the ggplot
r2<- ggplot() +
  geom_point(data = site_scores_df, aes(x = CCA1, y = CCA2, color = site, fill = site), shape = 21, size = 3) +
  scale_color_manual(values = site_col_vector) +
  scale_fill_manual(values = site_col_vector) +
  theme_minimal() +
  labs(title = "CCA Plot", x = "CCA1", y = "CCA2") +
  stat_ellipse(data = site_scores_df, aes(x = CCA1, y = CCA2, group = site), color = "black", size = 0.8) +
  geom_text_repel(data = species_scores_df, aes(x = CCA1, y = CCA2, label = species), color = "black", size = 3,  max.overlaps = Inf)
r2




```

## Networks in Net sampling

```{r net network treatment - with sankey}
# Reorder the columns of your data frame to match the desired order
desired_order <- c("Restored", "Depression", "Unrestored")
Abu_K_nt <- Abu_K_nt[, desired_order]


Abu_K_nt<-as.data.frame(Abu_K_nt)

# I need a long format
data_long <- Abu_K_nt %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")


# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", 
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey","grey","grey","grey","grey","grey","grey","grey","#26A69A","#FF5722","#CDDC39"])'
# Make the Network
sn<-sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=20, fontSize=8, nodePadding=1)


# Plot


# you save it as an html
saveNetwork(sn, "sn.html")

# you convert it as png
#webshot("sn.html","sn.png", vwidth = 1000, vheight = 900)

#data_long <- data_long %>% arrange(desc(value))


```

```{r net network metrics by site }
#Abu_K_nt matrix morphospecies by site 
#calcul des métriques 
null.t.test(Abu_K_nt, index=c("connectance","interaction evenness","H2","modularity"))



library(vegan)
obs3 <- unlist (networklevel (Abu_K_nt, index="connectance"))
obs3d <- unlist (networklevel (Abu_K_nt, index="H2"))
obs3e<-nestednodf(Abu_K_nt)
obs3m <- unlist (networklevel (Abu_K_nt, index="modularity"))
obs3r <- unlist (networklevel (Abu_K_nt, index="robustness"))
obs3m

obs3r
```

```{r net network season- sankey}



###Matrix per season 

UniMorpho <- unique(abundance_aggregated_n$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_n$season)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_n$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_N <- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_N) <- UniMorpho
colnames(Abu_K_N) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_n$season == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_n$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_n$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_N[i, j] <- Abui
  }
}


desired_order <- c("J", "A", "F") 
Abu_K_N<- Abu_K_N[,desired_order]
Abu_K_N<-as.data.frame(Abu_K_N)

# I need a long format
data_long <- Abu_K_N %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")
#data_long <- data_long %>% arrange(desc(value))

# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1



#ColourScal <- 'd3.scaleOrdinal().range(d3.schemeCategory10)'

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", 
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey","grey","grey","grey","grey","grey","grey","grey","#E31A1C","#1F78B4","#33A02C"])'
# Make the Network


sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=20, fontSize=7, nodePadding=1)


obs3 <- unlist (networklevel (Abu_K_N, index="connectance"))

obs3d <- unlist (networklevel (Abu_K_N, index="H2"))
obs3e<-nestednodf(Abu_K_nt)
obs3m <- unlist (networklevel (Abu_K_N, index="modularity"))
obs3
obs3m
obs3d
obs3e
```

```{r net network seasons- bipartite}

# Reorder your data based on the desired order haven't been possible

network <- plotweb(Abu_K_N, text.rot = 90,
                   col.high = c(rep("#E31A1C",1),rep("#1F78B4",1),rep("#33A02C",1)),
                   col.interaction = "#263238", 
                   high.spacing = 0.01,
                   low.spacing = 0.01,
                   col.low = "#FAFAFA",
                   bor.col.high = "white",
                   bor.col.low = "black",
                   bor.col.interaction = "darkgrey")



```

```{r net network metrics by season}
#calcul des métriques - Abu_K_N matrix net by season
null.t.test(Abu_K_N, index=c("connectance","interaction evenness","H2","modularity"))

library(vegan)
obs3 <- unlist (networklevel (Abu_K_N, index="connectance"))
obs3d <- unlist (networklevel (Abu_K_N, index="H2"))
obs3e<-nestednodf(Abu_K_N)
obs3m <- unlist (networklevel (Abu_K_N, index="modularity"))



```

```{r Net data subset per season and treatment for network}


subset_data_K_n_f <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net"& season == "F")
# Koyli Alpha selection depending on the pantraps

#All 

abundance_aggregated_N_F<-aggregate(Abun_tree ~ morphospecies+id_tree+site, data = subset_data_K_n_f, sum)#this will be modified depending on the specific guild or order studied 



subset_data_K_n_a <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net"& season == "A")
# Koyli Alpha selection depending on the pantraps

abundance_aggregated_N_A<-aggregate(Abun_tree ~ morphospecies+id_tree+site, data = subset_data_K_n_a, sum)#this will be modified depending on the specific guild or order studied 


subset_data_K_n_j <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net" & season == "J")
# Koyli Alpha selection depending on the pantraps
abundance_aggregated_N_J<-aggregate(Abun_tree ~ morphospecies+id_tree+functional_group+site, data = subset_data_K_n_j, sum)



subset_data_K_n_f <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net"& season == "F")
# Koyli Alpha selection depending on the pantraps

#All 

abundance_aggregated_N_F<-aggregate(Abun_tree ~ morphospecies+id_tree+site+Order+functional_group, data = subset_data_K_n_f, sum)#this will be modified depending on the specific guild or order studied 
abundance_aggregated_N_F<-abundance_aggregated_N_F%>%filter(Order %in% c("Hymenoptera", "Diptera"
  ))


subset_data_K_n_a <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net"& season == "A")
# Koyli Alpha selection depending on the pantraps

abundance_aggregated_N_A<-aggregate(Abun_tree ~ morphospecies+id_tree+site+Order+functional_group, data = subset_data_K_n_a, sum)#this will be modified depending on the specific guild or order studied 
abundance_aggregated_N_A<-abundance_aggregated_N_A%>%filter(Order %in% c("Hymenoptera", "Diptera"
  ))

subset_data_K_n_j <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net" & season == "J")
# Koyli Alpha selection depending on the pantraps
abundance_aggregated_N_J<-aggregate(Abun_tree ~ morphospecies+id_tree+functional_group+site+Order, data = subset_data_K_n_j, sum)
abundance_aggregated_N_J<-abundance_aggregated_N_J%>%filter(Order %in% c("Hymenoptera", "Diptera"
  ))

```

```{r net data matrix/id_tree February}

###Matrix per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

UniMorpho <- unique(abundance_aggregated_N_F$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_N_F$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_N_F$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_ntf<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_ntf) <- UniMorpho
colnames(Abu_K_ntf) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_N_F$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_N_F$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_N_F$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_ntf[i, j] <- Abui
  }
}



```

```{r net data matrix/id_tree August}

###Matrix per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

UniMorpho <- unique(abundance_aggregated_N_A$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_N_A$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_N_A$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_nta<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_nta) <- UniMorpho
colnames(Abu_K_nta) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_N_A$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_N_A$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_N_A$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_nta[i, j] <- Abui
  }
}




```

```{r net data matrix/id_tree June}

###Matrix per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

UniMorpho <- unique(abundance_aggregated_N_J$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_N_J$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_N_J$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_ntj<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_ntj) <- UniMorpho
colnames(Abu_K_ntj) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_N_J$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_N_J$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_N_J$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_ntj[i, j] <- Abui
  }
}


###Matrix per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

UniMorpho <- unique(abundance_aggregated_N_J$functional_group)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_N_J$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_N_J$functional_group), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_nj_g<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_nj_g) <- UniMorpho
colnames(Abu_K_nj_g) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_N_J$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_N_J$functional_group == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_N_J$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_nj_g[i, j] <- Abui
  }
}
Abu_K_nj_g


```

```{r Net data matrix/Id_tree}

###Matrix per season 

UniMorpho <- unique(abundance_aggregated_n$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_n$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_n$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_N_id <- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_N_id) <- UniMorpho
colnames(Abu_K_N_id) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_n$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_n$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_n$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_N_id[i, j] <- Abui
  }
}



```

```{r net data sankey network/id_tree in february per site}

Abu_K_ntf<-as.data.frame(Abu_K_ntf)

# I need a long format
data_long <- Abu_K_ntf %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")


# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "#26A69A","#26A69A","#26A69A","#26A69A","#26A69A","#FF5722", "#FF5722","#FF5722","#CDDC39", "#CDDC39","#CDDC39", "#CDDC39","#CDDC39"])'
# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=40, fontSize=8, nodePadding=2)






#data_long <- data_long %>% arrange(desc(value))


```

```{r net network metrics february}
#calcul des métriques 
null.t.test(Abu_K_ntf, index=c("connectance","interaction evenness","H2","modularity"))

library(vegan)
obs3 <- unlist (networklevel (Abu_K_ntf, index="connectance"))
obs3d <- unlist (networklevel (Abu_K_ntf, index="H2"))
obs3e<-nestednodf(Abu_K_ntf)
obs3m <- unlist (networklevel (Abu_K_ntf, index="modularity"))



```

```{r net data sankey network/id_tree in august per site}

Abu_K_nta<-as.data.frame(Abu_K_nta)

# I need a long format
data_long <- Abu_K_nta %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")


# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey","grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey","grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey","grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey","grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "#26A69A","#26A69A","#26A69A","#26A69A","#26A69A","#CDDC39","#FF5722","#FF5722","#FF5722","#FF5722","#FF5722","#CDDC39","#CDDC39","#CDDC39","#CDDC39", "#CDDC39"])'
# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=40, fontSize=8, nodePadding=2)





#data_long <- data_long %>% arrange(desc(value))


```

```{r net network metrics august}
#calcul des métriques 
null.t.test(Abu_K_nta, index=c("connectance","interaction evenness","H2","modularity"))

library(vegan)
obs3 <- unlist (networklevel (Abu_K_nta, index="connectance"))
obs3d <- unlist (networklevel (Abu_K_nta, index="H2"))
obs3e<-nestednodf(Abu_K_nta)
obs3m <- unlist (networklevel (Abu_K_nta, index="modularity"))



```

```{r net data sankey network/id_tree in june per site}

Abu_K_ntj<-as.data.frame(Abu_K_ntj)

# I need a long format
data_long <- Abu_K_ntj %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")


# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "#26A69A","#26A69A","#26A69A","#26A69A","#26A69A","#FF5722","#FF5722","#FF5722","#FF5722","#FF5722","#CDDC39","#CDDC39","#CDDC39","#CDDC39", "#CDDC39"])'
# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=40, fontSize=8, nodePadding=2)





#data_long <- data_long %>% arrange(desc(value))


```

```{r net network metrics june}
#calcul des métriques 
null.t.test(Abu_K_ntj, index=c("connectance","interaction evenness","H2","modularity"))

library(vegan)

obs3 <- unlist (networklevel (Abu_K_ntj, index="connectance"))
obs3d <- unlist (networklevel (Abu_K_ntj, index="H2"))
obs3e<-nestednodf(Abu_K_ntj)
obs3m <- unlist (networklevel (Abu_K_ntj, index="modularity"))



```

```{r net data heatmap of beta diversity per id_tree in per season}


#All 

subset_data_K_n_pol <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                          moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Net" & guild == "predator"& Order != "Lepidoptera")


#abundance_aggregated_fl<- left_join(data_ind_K,subset_data_K_n,by="id_tree", multiple = "all")
abundance_aggregated_nf<-aggregate(Abun_tree ~ morphospecies+id_tree+site+season+Family, data = subset_data_K_n_pol, sum)



###Matrix per season 

UniMorpho <- unique(abundance_aggregated_nf$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_nf$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_nf$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_N_m <- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_N_m) <- UniMorpho
colnames(Abu_K_N_m) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_nf$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_nf$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_nf$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_N_m[i, j] <- Abui
  }
}

mat<-as.matrix(Abu_K_N_m)



Abu_K_ntj_t<-t(Abu_K_ntj)
Abu_K_nta_t<-t(Abu_K_nta)
Abu_K_ntf_t<-t(Abu_K_ntf)



beta_ntj<-vegdist(Abu_K_ntj_t, method = "bray")
beta_nta<-vegdist(Abu_K_nta_t, method = "bray")
beta_ntf<-vegdist(Abu_K_ntf_t, method = "bray")


pheatmap(beta_ntj)
pheatmap(beta_nta)
pheatmap(beta_ntf)




```

# Pantrap related analysis

```{r Pantrap data subset}



# Koyli Alpha selection depending on the pantraps

#All 

subset_data_K_p <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Pantrap" )



abundance_aggregated_P<-aggregate(Abun_tree ~ morphospecies+id_tree+site+season, data = subset_data_K_p, sum)#this will be modified depending on the specific guild or order studied 

abundance_aggregated_p<- left_join(data_ind_K,abundance_aggregated_P,by="id_tree", multiple = "all")
#abundance_aggregated_p$flowering <- scale(abundance_aggregated$flowering)#rescale the flowering index

abundance_aggregated_p<- na.omit(abundance_aggregated_p)


```

```{r Pantrap Data preparation seasons}

###Matrix per season 

UniMorpho <- unique(abundance_aggregated_p$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_p$season)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_p$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_p<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_p) <- UniMorpho
colnames(Abu_K_p) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_p$season == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_p$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_p$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_p[i, j] <- Abui
  }
}

desired_order <- c("J", "A", "F") # Define the order as per your requirement

# Reorder your data based on the desired order
Abu_K_p <-Abu_K_p[, desired_order]


```

```{r Pantrap graphs/seasons}

##### Indices de diversité de Chao
ChaoRichness(Abu_K_p)#avec des dataframe, faire en fonction de ce que je cherche, par exemple tel que c'est fait, methode, site, localité, saison
ChaoShannon(Abu_K_p)
DataInfo(Abu_K_p)


data_info <- DataInfo(Abu_K_p)
data_info$Assemblage<-factor((data_info$Assemblage), levels = desired_order)
# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = n, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = n), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the abundance per season - Koyli Alpha/Pantrap ",
       x = "Season",
       y = "Total abundance") +
  theme_minimal()



data_info <- ChaoRichness(Abu_K_p)
data_info$Assemblage<-factor(rownames(data_info), levels = desired_order)

# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = Observed, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Observed), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the species richness per season - Koyli Alpha/Pantrap",
       x = "Season",
       y = "Species richness") +
  theme_minimal()


###par saison Net
NEXKP<-data.frame(Abu_K_p)
Ju<-nrow(subset(NEXKP, NEXKP$J>0))
Au<-nrow(subset(NEXKP, NEXKP$A>0))
Fe<-nrow(subset(NEXKP, NEXKP$F>0))

JA<-nrow(subset(NEXKP, NEXKP$J>0 & NEXKP$A>0))
JF<-nrow(subset(NEXKP, NEXKP$J>0 & NEXKP$F>0)) 
FA<-nrow(subset(NEXKP, NEXKP$F>0 & NEXKP$A>0)) 
JAF<-nrow(subset(NEXKP, NEXKP$J>0 & NEXKP$A>0 & NEXKP$F>0))


grid.newpage()
draw.triple.venn(area1 = Ju, area2 = Au , area3 = Fe, n12 = JA, n23 = FA, n13 = JF, 
                 n123 = JAF, category = c("June", "August", "February"), lty = "blank", 
                 fill = c("#1F78B4", "#33A02C", "#E31A1C"))



#q =c(0,1,2) pour les indices de Hill

nex<-iNEXT(Abu_K_p, q=0, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex, type=1)
df
df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn0<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values=c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C"))+scale_fill_manual(values=c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C"))+
  labs(x="Abundance" , y = "q=0") +
  ggtitle("Pantrap - Koyli Alpha")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 


ekn0#courbe de rarefaction (changer le nombre de Hill si nécessaire)


nex2<-iNEXT(Abu_K_p, q=2, datatype="abundance", size=NULL, endpoint=1000, se=TRUE, conf=0.95)
df <- fortify(nex2, type=1)
df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)
df

ekn2 <- ggplot(df, aes(x = x, y = y, colour = Assemblage)) + 
  geom_point(aes(shape = Assemblage), size = 3, data = df.point) +
  geom_line(aes(linetype = Method), lwd = 1, data = df.line) +
  geom_ribbon(aes(ymin = y.lwr, ymax = y.upr,
                  fill = Assemblage, colour = NULL), alpha = 0.2) +
  scale_color_manual(values = c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C")) +
  scale_fill_manual(values = c("J"="#E31A1C","A"="#1F78B4", "F"="#33A02C")) +
  labs(x = "Abundance" , y = "q=2") +
  ggtitle("Pantrap - Koyli Alpha")  +
  theme(legend.position = "bottom", 
        legend.title = element_blank(),
        text = element_text(size = 10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 


ekn2#courbe de rarefaction (changer le nombre de Hill si nécessaire)



```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

```{r Pantrap data preparation/treatment}

###Matrix per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

UniMorpho <- unique(abundance_aggregated_p$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_p$site)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_p$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_pt<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_pt) <- UniMorpho
colnames(Abu_K_pt) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_p$site == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_p$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_p$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_pt[i, j] <- Abui
  }
}


desired_order <- c("Restored", "Depression", "Unrestored") # Define the order as per your requirement

# Reorder your data based on the desired order
Abu_K_pt <-Abu_K_pt[, desired_order]


```

```{r Pantrap graphs/treatments}

#Descriptive graphs per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

#####Chao diversity indexes 

ChaoRichness(Abu_K_pt) 
ChaoShannon(Abu_K_pt)
DataInfo(Abu_K_pt)

#barplot for the abundance
data_info <- DataInfo(Abu_K_pt)
data_info$Assemblage<-factor((data_info$Assemblage), levels = desired_order)

# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = n, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c("Unrestored" = "#FF5722", 
                     "Depression" = "#CDDC39", 
                     "Restored" = "#26A69A"))+
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = n), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the abundance per treatment - Koyli Alpha/Pantrap ",
       x = "Site",
       y = "Total abundance") +
  theme_minimal()


#barplot for the species richnes 
data_info <- ChaoRichness(Abu_K_pt)
data_info$Assemblage<-factor(rownames(data_info), levels = desired_order)

# Plot bar chart for 'n' and 'S.obs'
ggplot(data_info, aes(x = Assemblage, y = Observed, fill = Assemblage)) +
  theme_bw() +
  scale_fill_manual(values = c("Unrestored" = "#FF5722", 
                     "Depression" = "#CDDC39", 
                     "Restored" = "#26A69A")) +
  geom_bar(stat = "identity", position = "dodge") +
  geom_text(aes(label = Observed), vjust = -0.3, position = position_dodge(width = 0.9)) +
  labs(title = "Bar Plot for the species richness per treatment - Koyli Alpha/Pantrap",
       x = "Site",
       y = "Species richness") +
  theme_minimal()


###par saison Net
NEXKPt<-data.frame(Abu_K_pt)
Un<-nrow(subset(NEXKPt, NEXKPt$Unrestored>0))
Und<-nrow(subset(NEXKPt, NEXKPt$Depression>0))
Res<-nrow(subset(NEXKPt, NEXKPt$Restored>0))

UUD<-nrow(subset(NEXKPt, NEXKPt$Unrestored>0 & NEXKPt$Depression>0))
UR<-nrow(subset(NEXKPt, NEXKPt$Unrestored>0 & NEXKPt$Restored>0)) 
RUD<-nrow(subset(NEXKPt, NEXKPt$Restored>0 & NEXKPt$Depression>0)) 
UUDR<-nrow(subset(NEXKPt, NEXKPt$Unrestoresd>0 & NEXKPt$Depression>0 & NEXKPt$Restored>0))


grid.newpage()
draw.triple.venn(area1 = Un, area2 = Und , area3 = Res, n12 = UUD, n23 = RUD, n13 = UR, 
                 n123 = UUDR, category = c("Unrestored", "Unrestored depression", "Restored"), lty = "blank", 
                 fill = c("#FF5722", "#CDDC39", "#26A69A"))

## color code per sitec(rep("#26A69A",1), rep("#CDDC39",1), rep("#FF5722",1))


#q =c(0,1,2) pour les indices de Hill

nex<-iNEXT(Abu_K_pt, q=0, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex, type=1)

df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn0<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values= c("Unrestored" = "#FF5722", 
                     "Depression" = "#CDDC39", 
                     "Restored" = "#26A69A"))+scale_fill_manual(values=c("Unrestored" = "#FF5722", 
                     "Depression" = "#CDDC39", 
                     "Restored" = "#26A69A"))+
  labs(x="q=0", y="Species richness") +
  ggtitle("Pantrap - Koyli Alpha")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 





nex2<-iNEXT(Abu_K_pt, q=2, datatype="abundance", size=NULL, endpoint=3000, se=TRUE, conf=0.95)
df <- fortify(nex2, type=1)
df.point <- df[df$Method=="Observed",]
df.line <- df[df$Method!="Observed",]
df.line$Method <- as.factor(df.line$Method)

ekn2<-ggplot(df, aes(x=x, y=y, colour=Assemblage)) + 
  geom_point(aes(shape=Assemblage), size=3, data=df.point) +
  geom_line(aes(linetype=Method), lwd=1, data=df.line) +
  geom_ribbon(aes(ymin=y.lwr, ymax=y.upr,
                  fill=Assemblage, colour=NULL), alpha=0.2) +
  scale_color_manual(values= c("Unrestored" = "#FF5722", 
                     "Depression" = "#CDDC39", 
                     "Restored" = "#26A69A"))+scale_fill_manual(values=c("Unrestored" = "#FF5722", 
                     "Depression" = "#CDDC39", 
                     "Restored" = "#26A69A"))+
  labs(x="q=2", y="Species richness") +
  ggtitle("Pantrap - Koyli Alpha")  +
  theme(legend.position = "bottom", 
        legend.title=element_blank(),
        text=element_text(size=10),
        legend.box = "vertical",
        panel.background = element_blank(),  # Remove background color
        plot.background = element_blank()) 

ekn0#courbe de rarefaction (changer le nombre de Hill si nécessaire)
ekn2#courbe de rarefaction (changer le nombre de Hill si nécessaire)



```

## Networks in pantrap

```{r pantrap network treatment - with sankey}
# Reorder the columns of your data frame to match the desired order
desired_order <- c("Restored", "Depression", "Unrestored")
Abu_K_pt <- Abu_K_pt[, desired_order]


Abu_K_pt<-as.data.frame(Abu_K_pt)

# I need a long format
data_long <- Abu_K_pt %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")
data_long

# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey","grey","grey","grey","grey","grey","grey","#26A69A","#FF5722","#CDDC39"])'
# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=40, fontSize=8, nodePadding=2)






#data_long <- data_long %>% arrange(desc(value))


```

```{r pantrap network metrics/site}
#calcul des métriques 
null.t.test(Abu_K_pt, index=c("connectance","interaction evenness","H2","modularity"))



library(vegan)
obs3 <- unlist (networklevel (Abu_K_pt, index="connectance"))
obs3d <- unlist (networklevel (Abu_K_pt, index="H2"))
obs3e<-nestednodf(Abu_K_pt)
obs3m <- unlist (networklevel (Abu_K_pt, index="modularity"))
obs3m


```

```{r pantrap network season- sankey}

Abu_K_p<-as.data.frame(Abu_K_p)

# I need a long format
data_long <- Abu_K_p %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")
#data_long <- data_long %>% arrange(desc(value))
data_long
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

nodes

#ColourScal <- 'd3.scaleOrdinal().range(d3.schemeCategory10)'

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey","grey","grey","grey","grey","grey","grey","#E31A1C","#1F78B4","#33A02C"])'
# Make the Network


sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=40, fontSize=8, nodePadding=2)

```

```{r network seasons- bipartite}

# Reorder your data based on the desired order, but no possible till now

network <- plotweb(Abu_K_p, text.rot = 90,
                   col.high = c(rep("#E31A1C",1),rep("#1F78B4",1),rep("#33A02C",1)),
                   col.interaction = "#263238", 
                   high.spacing = 0.01,
                   low.spacing = 0.01,
                   col.low = "#FAFAFA",
                   bor.col.high = "white",
                   bor.col.low = "black",
                   bor.col.interaction = "darkgrey")



```

```{r pantrap network metrics/season}
#calcul des métriques 
null.t.test(Abu_K_p, index=c("connectance","interaction evenness","H2","modularity"))



library(vegan)
obs3 <- unlist (networklevel (Abu_K_p, index="connectance"))
obs3d <- unlist (networklevel (Abu_K_p, index="H2"))
obs3e<-nestednodf(Abu_K_p)
obs3m <- unlist (networklevel (Abu_K_p, index="modularity"))
obs3all<-unlist(networklevel(Abu_K_p))

obs3all
```

```{r Pantrap data subset/individually}


subset_data_K_p_f <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Pantrap"& season == "F")
# Koyli Alpha selection depending on the pantraps

#All 

abundance_aggregated_P_F<-aggregate(Abun_tree ~ morphospecies+id_tree+site, data = subset_data_K_p_f, sum)#this will be modified depending on the specific guild or order studied 



subset_data_K_p_a <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Pantrap"& season == "A")
# Koyli Alpha selection depending on the pantraps

abundance_aggregated_P_A<-aggregate(Abun_tree ~ morphospecies+id_tree+site, data = subset_data_K_p_a, sum)#this will be modified depending on the specific guild or order studied 


subset_data_K_p_j <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Pantrap"& season == "J")
# Koyli Alpha selection depending on the pantraps
abundance_aggregated_P_J<-aggregate(Abun_tree ~ morphospecies+id_tree+site, data = subset_data_K_p_j, sum)


```

```{r Pantrap data matrix/id_tree February}

###Matrix per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

UniMorpho <- unique(abundance_aggregated_P_F$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_P_F$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_P_F$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_ptf<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_ptf) <- UniMorpho
colnames(Abu_K_ptf) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_P_F$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_P_F$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_P_F$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_ptf[i, j] <- Abui
  }
}



```

```{r Pantrap data matrix/id_tree August}

###Matrix per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

UniMorpho <- unique(abundance_aggregated_P_A$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_P_A$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_P_A$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_pta<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_pta) <- UniMorpho
colnames(Abu_K_pta) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_P_A$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_P_A$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_P_A$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_pta[i, j] <- Abui
  }
}




```

```{r Pantrap data matrix/id_tree June}

###Matrix per treatment (Unrestored, Unrestored depression and Restored) in Koyli Alpha

UniMorpho <- unique(abundance_aggregated_P_J$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_P_J$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_P_J$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_ptj<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_ptj) <- UniMorpho
colnames(Abu_K_ptj) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_P_J$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_P_J$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_P_J$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_ptj[i, j] <- Abui
  }
}
```

```{r Pantrap data sankey network/id_tree in february per site}

Abu_K_ptf<-as.data.frame(Abu_K_ptf)

# I need a long format
data_long <- Abu_K_ptf %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")
data_long

# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "#26A69A","#26A69A","#26A69A","#FF5722", "#FF5722","#CDDC39", "#CDDC39","#CDDC39"])'
# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=40, fontSize=8, nodePadding=2)






#data_long <- data_long %>% arrange(desc(value))


```

```{r Pantrap data sankey network/id_tree in august per site}

Abu_K_pta<-as.data.frame(Abu_K_pta)

# I need a long format
data_long <- Abu_K_pta %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")

data_long
# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1
data_long
my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey","grey", "grey","grey","grey","grey","#26A69A","#26A69A","#26A69A","#FF5722", "#FF5722", "#FF5722","#FF5722", "#CDDC39","#CDDC39","#CDDC39"])'
# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=40, fontSize=8, nodePadding=2)

```

```{r pantrap data sankey network/id_tree in june per site}

Abu_K_ptj<-as.data.frame(Abu_K_ptj)

# I need a long format
data_long <- Abu_K_ptj %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")
data_long

# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "#26A69A","#26A69A","#26A69A","#FF5722","#FF5722","#FF5722","#CDDC39","#CDDC39","#CDDC39"])'
# Make the Network
sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=40, fontSize=8, nodePadding=2)





#data_long <- data_long %>% arrange(desc(value))



```

```{r Pantrap Data preparation / id_tree}

###Matrix per season 

UniMorpho <- unique(abundance_aggregated_p$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_p$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_p$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_p_id<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_p_id) <- UniMorpho
colnames(Abu_K_p_id) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_p$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_p$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_p$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_p_id[i, j] <- Abui
  }
}

```

## CCA in Pantrap sampling

```{r Pantrap cca - preparation}
#data preparation - subset of the data of interest

subset_data_K_p_netw<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                              moment == "jour"& Locality == "Koyli_Alpha"& Methode== "Pantrap" & Order != "Lepidoptera")

#abundance_aggregated_fl<- left_join(data_ind_K,subset_data_K_n,by="id_tree", multiple = "all")
abundance_aggregated_netw<-aggregate(Abun_tree ~ morphospecies+id_tree+site+season+Family+Order+functional_group, data = subset_data_K_p_netw, sum)#this will be modified depending on the specific guild or order studied 


##with this line change the degree of filtering (by order, functional group or other interesting question that needs to be explore)
abundance_aggregated_netw<-abundance_aggregated_netw %>%
      filter(functional_group %in% 
           c("pollinator_diptera", "pollinator_hymenoptera", 
             "predatory_diptera", "predatory_hymenoptera")) %>%
      filter(Order %in% c("Hymenoptera", "Diptera"))

###Matrix per season 

UniMorpho <- unique(abundance_aggregated_netw$Family)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_netw$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_netw$Family), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_N_fam <- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_N_fam) <- UniMorpho
colnames(Abu_K_N_fam) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_netw$id_tree== uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_netw$Family == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_netw$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_N_fam[i, j] <- Abui
  }
}


Abu_K_N_fam
transposed_matrix_n_id<-t(Abu_K_N_fam)


##preparation dataset for cca
#for abundance 
species_data<-transposed_matrix_n_id
as.data.frame(species_data)

# Create a dataframe from the matrix
my_data_species <- as.data.frame(species_data, row.names = NULL)
my_data_species$id_tree <- rownames(species_data)
# Reset row names of the dataframe
rownames(my_data_species) <- NULL

#for presence /absence 
species_presence_absence <- ifelse(species_data > 0, 1, 0)
#Create a dataframe from the matrix
my_data_species <- as.data.frame(species_presence_absence, row.names = NULL)
my_data_species$id_tree <- rownames(species_presence_absence)
# Reset row names of the dataframe
rownames(my_data_species) <- NULL



#preparing environmental data
subset_data_cca <- unique(abundance_aggregated_netw[, c("id_tree","site", "season")])
rownames(subset_data_cca) <- subset_data_cca$id_tree
subset_data_cca$id_tree <- NULL


#cca model and test assumptions

env_data<-subset_data_cca
desired_order<-c("J","A","F")
env_data$season <- factor(env_data$season, levels = desired_order)

```

```{r Pantrap cca - models }

#presence/absence cca
cca_result <- cca(species_presence_absence, env_data)
cca_result2<-cca(species_presence_absence~season + Condition(site), data= env_data)
cca_result3<-cca(species_presence_absence~site + Condition(season), data= env_data)



anova(cca_result, permutations = 199)
anova(cca_result2, permutations = 199)
anova(cca_result3, permutations = 199)

#abundance cca
cca_model<-cca(species_data, env_data)
cca_model2<-cca(species_data~season + Condition(site), data= env_data)
cca_model3<-cca(species_data~site + Condition(season), data= env_data)


anova(cca_model, permutations = 199)
anova(cca_model2, permutations = 199)
anova(cca_model3, permutations = 199)

anova (cca_model2, by = "mar", permutations = 199)
anova (cca_model3, by = "ter", permutations = 199)
anova (cca_model3, by = "axis", permutations = 199)




###cca plot with ggplot
plot(cca_model3)
plot(cca_model2)

summary(cca_model3)
summary(cca_model2)


#plot for cca_model2

# Extract site and species scores
site_scores <- scores(cca_model2, display = "sites")
site_scores_df <- as.data.frame(site_scores)
site_scores_df$site <- env_data$site
site_scores_df$season <- env_data$season

# Convert scores to data frames
species_scores <- scores(cca_model2, display = "species")
species_scores_df <- as.data.frame(species_scores)
species_scores_df$species <- rownames(species_scores_df)

# Add site and season information to site_scores_df


# Define a color vector for sites using a palette
site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Set1")
names(site_col_vector) <- c("J", "A", "F")

# Define a color vector for sites using a palette
#site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Dark2") 
#names(site_col_vector) <- c("Depression","Unrestored","Restored")


# Create the ggplot
p1 <- ggplot() +
  geom_point(data = site_scores_df, aes(x = CCA1, y = CCA2, color = season, fill = season), shape = 21, size = 3) +
  scale_color_manual(values = site_col_vector) +
  scale_fill_manual(values = site_col_vector) +
  theme_minimal() +
  labs(title = "CCA Plot", x = "CCA1", y = "CCA2") +
  stat_ellipse(data = site_scores_df, aes(x = CCA1, y = CCA2, group = season), color = "black", size = 0.8)+
  geom_text_repel(data = species_scores_df, aes(x = CCA1, y = CCA2, label = species), color = "black", size = 3,  max.overlaps = Inf)

# Print the plot
p1

#plot for cca_model3

# Assuming your CCA model is named cca_model2
# Extract scores for sites and species
site_scores <- scores(cca_model3, display = "sites")
# Convert to data frames for ggplot2
site_scores_df <- as.data.frame(site_scores)
site_scores_df$site <- env_data$site
site_scores_df$season <- env_data$season


species_scores <- scores(cca_model3, display = "species")
species_scores_df <- as.data.frame(species_scores)
species_scores_df$species <- rownames(species_scores_df)

# Define a color vector for sites using a palette
site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Dark2") 
names(site_col_vector) <- c("Depression","Unrestored","Restored")


# Create the ggplot
p2<- ggplot() +
  geom_point(data = site_scores_df, aes(x = CCA1, y = CCA2, color = site, fill = site), shape = 21, size = 3) +
  scale_color_manual(values = site_col_vector) +
  scale_fill_manual(values = site_col_vector) +
  theme_minimal() +
  labs(title = "CCA Plot", x = "CCA1", y = "CCA2") +
  stat_ellipse(data = site_scores_df, aes(x = CCA1, y = CCA2, group = site), color = "black", size = 0.8) +
  geom_text_repel(data = species_scores_df, aes(x = CCA1, y = CCA2, label = species), color = "black", size = 3,  max.overlaps = Inf)
p2


#cca_result2


# Extract site and species scores
site_scores <- scores(cca_result2, display = "sites")
site_scores_df <- as.data.frame(site_scores)
site_scores_df$site <- env_data$site
site_scores_df$season <- env_data$season

# Convert scores to data frames
species_scores <- scores(cca_result2, display = "species")
species_scores_df <- as.data.frame(species_scores)
species_scores_df$species <- rownames(species_scores_df)

# Add site and season information to site_scores_df


# Define a color vector for sites using a palette
site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Set1")
names(site_col_vector) <- c("J", "A", "F")

# Define a color vector for sites using a palette
#site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Dark2") 
#names(site_col_vector) <- c("Depression","Unrestored","Restored")


# Create the ggplot
r1 <- ggplot() +
  geom_point(data = site_scores_df, aes(x = CCA1, y = CCA2, color = season, fill = season), shape = 21, size = 3) +
  scale_color_manual(values = site_col_vector) +
  scale_fill_manual(values = site_col_vector) +
  theme_minimal() +
  labs(title = "CCA Plot", x = "CCA1", y = "CCA2") +
  stat_ellipse(data = site_scores_df, aes(x = CCA1, y = CCA2, group = season), color = "black", size = 0.8)+
  geom_text_repel(data = species_scores_df, aes(x = CCA1, y = CCA2, label = species), color = "black", size = 3,  max.overlaps = Inf)

# Print the plot
r1


#cca_result3
# Assuming your CCA model is named cca_model2
# Extract scores for sites and species
site_scores <- scores(cca_result3, display = "sites")
# Convert to data frames for ggplot2
site_scores_df <- as.data.frame(site_scores)
site_scores_df$site <- env_data$site
site_scores_df$season <- env_data$season


species_scores <- scores(cca_result3, display = "species")
species_scores_df <- as.data.frame(species_scores)
species_scores_df$species <- rownames(species_scores_df)

# Define a color vector for sites using a palette
site_col_vector <- RColorBrewer::brewer.pal(n = 3, name = "Dark2") 
names(site_col_vector) <- c("Depression","Unrestored","Restored")


# Create the ggplot
r2<- ggplot() +
  geom_point(data = site_scores_df, aes(x = CCA1, y = CCA2, color = site, fill = site), shape = 21, size = 3) +
  scale_color_manual(values = site_col_vector) +
  scale_fill_manual(values = site_col_vector) +
  theme_minimal() +
  labs(title = "CCA Plot", x = "CCA1", y = "CCA2") +
  stat_ellipse(data = site_scores_df, aes(x = CCA1, y = CCA2, group = site), color = "black", size = 0.8) +
  geom_text_repel(data = species_scores_df, aes(x = CCA1, y = CCA2, label = species), color = "black", size = 3,  max.overlaps = Inf)
r2



```

# Pantrap glmm

```{r pantrap glmm models -pantraps }


#pantrap

subset_data_K_p <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha"& Methode == "Pantrap" )



abundance_aggregated_pg<-aggregate(Abun_tree ~id_tree+ site+season, data = subset_data_K_p, sum)#this will be modified depending on the specific guild or order studied 


desired_order <- c("J", "A", "F") 
abundance_aggregated_pg$season<- factor(abundance_aggregated_pg$season, levels = desired_order)

ggplot(abundance_aggregated_pg) +
  aes(x = Abun_tree, y = season, fill = season) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Set1", direction = 1) +
  scale_x_continuous(trans = "log10") +
  coord_flip() +
  theme_minimal()+
  theme(
    axis.text.y = element_text(size = 13L),
    axis.text.x = element_text(size = 13L)
  ) 




###glmm model


candidate_models_Abun1<- list(
glmbn4=glmer.nb(Abun_tree ~ site+(1|season), data = abundance_aggregated_pg, control = glmerControl(optimizer = "bobyqa")),

glmbn5=glmer.nb(Abun_tree ~ season+(1|site), data = abundance_aggregated_pg, control = glmerControl(optimizer = "bobyqa"))
)





candidate_models_Abun1


aic_data <- data.frame(Model = character(), AIC = numeric())

# Calculate AIC for each model
for (model_name in names(candidate_models_Abun1)) {
  model <- candidate_models_Abun1[[model_name]]
  aic <- AIC(model)
  aic_data <- rbind(aic_data, data.frame(Model = model_name, AIC = aic))
}

 aic_data


# Control argument specifies the way we optimize the
# parameter values

glmbn4=glm.nb(Abun_tree ~ site, data = abundance_aggregated_pg)


glmbn5=glmer.nb(Abun_tree ~ season+(1|site), data = abundance_aggregated_pg, control = glmerControl(optimizer = "bobyqa"))
summary(glmbn5)







#Estimation des paramètres du modèle par l'approximation de Laplace(Bolker, 2008) -> trop de facteurs aléatoires nécessaires au calcul du modèle pour faire une quadrature de Gausse-Hermite (impossible pour la fonction si plus de 1 et en général si + de 2,3)


summary(glmbn4)
summary(glmbn5)




Anova(glmbn4, type=3, method="chisq") 


Anova(glmbn5, type=3, method="chisq") #methode chis2 car glmer et type 3 car plan déséuilibré




#Test des résidus
library(DHARMa)


plot(simulateResiduals(glmbn4))

plot(simulateResiduals(glmbn5))




library(MuMIn) #Détermination du r2

r.squaredGLMM(glmbn4)
r.squaredGLMM(glmbn5)







emtb1 <- lsmeans(glmbn4, ~ site)
pairs(emtb1)

emtb11 <- lsmeans(glmbn42, ~ site)
pairs(emtb11)

emtb2 <- lsmeans(glmbn5, ~ season) #changer l'écriture de la formule
pairs(emtb2)






model2ab <- lm(log1p(Abun_tree) ~ season, data = abundance_aggregated_pg)
summary(model2ab)

plot(simulateResiduals(model2ab))
Anova(model2ab, type=3, method="chisq")


model3ab <- lm(log1p(Abun_tree) ~ site, data = abundance_aggregated_pg)
summary(model3ab)

plot(simulateResiduals(model3ab))
Anova(model3ab, type=3, method="chisq")
emtb22 <- lsmeans(glmbn5_simplified, ~ season) #changer l'écriture de la formule
pairs(emtb22)




glmbn5_simplified <- glm.nb(Abun_tree ~ season, data = abundance_aggregated_pg)
summary(glmbn5_simplified)
Anova(glmbn5_simplified, type=3, method="chisq")
plot(simulateResiduals(glmbn5_simplified))
emtb22 <- lsmeans(glmbn5_simplified, ~ season) #changer l'écriture de la formule
pairs(emtb22)
r.squaredGLMM(glmbn5_simplified)
#R2m représente le r avec seulement les effets fixes, et r2c il y a les effets de groupes
#trigamma la plus fiabl


```

```{r pantrap data abundance matrix/id_tree}
abundance_aggregated_pg<-aggregate(Abun_tree ~id_tree+ site+season+morphospecies, data = subset_data_K_p, sum)

desired_order <- c("J", "A", "F") 
abundance_aggregated_pg$season<- factor(abundance_aggregated_pg$season, levels = desired_order)

abundance_aggregated_pg<- na.omit(abundance_aggregated_pg)

###Matrix per treatment

UniMorpho <- unique(abundance_aggregated_pg$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_pg$id_tree)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_pg$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_tp<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_tp) <- UniMorpho
colnames(Abu_K_tp) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_pg$id_tree == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_pg$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_pg$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_tp[i, j] <- Abui
  }
}


ChaoRichness(Abu_K_tp)#avec des dataframe, faire en fonction de ce que je cherche, par exemple tel que c'est fait, methode, site, localité, saison
ChaoShannon(Abu_K_tp)
DataInfo(Abu_K_tp)



#data_info <- DataInfo(Abu_K_tn)
# Plot bar chart for 'n' and 'S.obs'
#ggplot(data_info, aes(x = Assemblage, y = n, fill = Assemblage)) +
#  theme_bw() +
#  geom_bar(stat = "identity", position = "dodge") +
#  labs(title = "Bar Plot for the abundance per id_tree - Koyli Alpha",
#       x= "Tree ID",      
#       y = "Total abundance") +
#  theme_minimal()


#data_info <- ChaoRichness(Abu_K_tn)
#data_info$id_tree<-rownames(data_info)
# Plot bar chart for 'n' and 'S.obs'
#ggplot(data_info, aes(x = id_tree, y = Observed, fill = id_tree)) +
#  theme_bw() +
#  geom_bar(stat = "identity", position = "dodge") +
#    labs(title = "Bar Plot for the species richness per treatment  - Koyli Alpha",
#          x= "Tree ID",     
#         y = "Species richness") +
#  theme_minimal()


#Diversity index - q=0,1,2 - Species richness, Shannon, Simpson

q0_resultp <- iNEXT(Abu_K_tp, q = 0, datatype = "abundance")

q2_resultp <- iNEXT(Abu_K_tp, q = 2, datatype = "abundance")
q1_resultp <- iNEXT(Abu_K_tp, q = 1, datatype = "abundance")


q2_resultp[["AsyEst"]]$id_tree<-q2_resultp[["AsyEst"]]$Assemblage
q1_resultp[["AsyEst"]]$id_tree<-q2_resultp[["AsyEst"]]$Assemblage
q0_resultp[["AsyEst"]]$id_tree<-q2_resultp[["AsyEst"]]$Assemblage



dataq2p <- subset(q2_resultp[["AsyEst"]],
                        Diversity == "Simpson diversity")
dataq0p <- subset(q0_resultp[["AsyEst"]],
                        Diversity == "Species richness")

dataq1p <- subset(q1_resultp[["AsyEst"]],
                        Diversity == "Shannon diversity")



```

```{r pantrap glmm models simpson}
#faire une transformation log + 1 s'il y a des valeurs en 0 et tester gaussian distribution

#simpson diversity dataq2$Observed



### i have removed the glmer gamma
 
 
subset_data_ndiversity1p<- left_join(dataq1p,abundance_aggregated_pg,by="id_tree", multiple = "all")
abundance_aggregated_g1p <- unique(subset_data_ndiversity1p[, c("id_tree", "site", "season", "Observed")])

subset_data_ndiversity0p<- left_join(dataq0p,abundance_aggregated_pg,by="id_tree", multiple = "all")

abundance_aggregated_g0p <- unique(subset_data_ndiversity0p[, c("id_tree", "site", "season", "Observed")])

ggplot(abundance_aggregated_g0p) +
  aes(x = Observed, y = season, fill = season) +
  geom_boxplot() +
  scale_fill_brewer(palette = "Set1", direction = 1) +
  coord_flip() +
  theme_minimal()+
  theme(
    axis.text.y = element_text(size = 13L),
    axis.text.x = element_text(size = 13L)
  ) 


subset_data_ndiversity2p<- left_join(dataq2p,abundance_aggregated_pg,by="id_tree", multiple = "all")
abundance_aggregated_g2p <- unique(subset_data_ndiversity2p[, c("id_tree", "site", "season", "Observed")])

 

# Replacement for modelsea0
modelsea0 <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g0p)


# Replacement for modelsea1
modelsea1 <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g1p)

# Replacement for modelsea2
modelsea2 <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g2p)




modelsit0 <- lmer(log1p(Observed) ~ site + (1|season),
              data = abundance_aggregated_g0p)
modelsit1 <- lmer(log1p(Observed) ~ site + (1|season),
              data = abundance_aggregated_g1p)

modelsit2 <- lmer(log1p(Observed) ~ site + (1|season),
              data = abundance_aggregated_g2p)


# View the results

summary(modelsea0)
summary(modelsea1)
summary(modelsea2)

summary(modelsit0)
summary(modelsit1)
summary(modelsit2)



# Replacement for modelsea0 with releveling
modelsea0_replacement <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g0p)
summary(modelsea0_replacement)

# Replacement for modelsea1 with releveling
modelsea1_replacement <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g1p)
summary(modelsea1_replacement)

# Replacement for modelsea2 with releveling
modelsea2_replacement <- lm(log1p(Observed) ~ season, data = abundance_aggregated_g2p)
summary(modelsea2_replacement)



Anova(modelsea1, type=3, method="chisq")
Anova(modelsea0, type=3, method="chisq")
Anova(modelsea2, type=3, method="chisq")
Anova(modelsit1, type=3, method="chisq")
Anova(modelsit2, type=3, method="chisq")
Anova(modelsit0, type=3, method="chisq")

#Test des résidus
library(DHARMa)



plot(simulateResiduals(modelsea1))
plot(simulateResiduals(modelsea0))
plot(simulateResiduals(modelsea2))


plot(simulateResiduals(modelsit1))
#plot(simulateResiduals(modelsit0))
plot(simulateResiduals(modelsit2))

library(MuMIn) #Détermination du r2

r.squaredGLMM(modelsit1)
#r.squaredGLMM(modelsit0)
r.squaredGLMM(modelsit2)

#R2m représente le r avec seulement les effets fixes, et r2c il y a les effets de groupes
#trigamma la plus fiabl




emtb1 <- lsmeans(modelsit1, ~ site)
pairs(emtb1)

#emtb0 <- lsmeans(modelsit0, ~ site)
#pairs(emtb0)


emtb2 <- lsmeans(modelsit2, ~ site)
pairs(emtb2)







```

```{r pantrap glmm models species richness}

###glmm model

summary(abundance_aggregated_g0p$Observed)
candidate_models_sper1<- list(
glmbn4=glmer.nb(Observed ~ site+(1|season), data = abundance_aggregated_g0p, control = glmerControl(optimizer = "bobyqa"))

)

candidate_models_sper1


aic_data <- data.frame(Model = character(), AIC = numeric())

# Calculate AIC for each model
for (model_name in names(candidate_models_sper1)) {
  model <- candidate_models_sper1[[model_name]]
  aic <- AIC(model)
  aic_data <- rbind(aic_data, data.frame(Model = model_name, AIC = aic))
}

 aic_data


# Control argument specifies the way we optimize the
# parameter values

glmbn4q=glmmPQL(Observed ~ site, random = ~ 1 | season,data = abundance_aggregated_g0p, family = quasipoisson())


glmbn4=glmer.nb(Observed ~ site+(1|season), data = abundance_aggregated_g0p, control = glmerControl(optimizer = "bobyqa"))



#Estimation des paramètres du modèle par l'approximation de Laplace(Bolker, 2008) -> trop de facteurs aléatoires nécessaires au calcul du modèle pour faire une quadrature de Gausse-Hermite (impossible pour la fonction si plus de 1 et en général si + de 2,3)

summary(glmbn4)



Anova(glmbn4, type=3, method="chisq") 





#Test des résidus
library(DHARMa)


plot(simulateResiduals(glmbn4))




library(MuMIn) #Détermination du r2

r.squaredGLMM(glmbn4)


#R2m représente le r avec seulement les effets fixes, et r2c il y a les effets de groupes
#trigamma la plus fiabl




emtb1 <- lsmeans(glmbn4, ~ site)
pairs(emtb1)





#residuals <- residuals(glmbn4)

# Create diagnostic plots
#plot_residuals <- data.frame(
#   Fitted = fitted(glmbn4),
#  Residuals = residuals
#)

# Residual vs. Fitted plot
#ggplot(plot_residuals, aes(x = Fitted, y = Residuals)) +
 # geom_point() +
  #geom_hline(yintercept = 0, linetype = "dashed") +
  #labs(x = "Fitted values", y = "Residuals") +
  #ggtitle("Residuals vs. Fitted")

# QQ plot
#qqnorm(residuals)
#qqline(residuals)

# Scale-Location plot
#ggplot(plot_residuals, aes(x = Fitted, y = abs(sqrt(abs(Residuals))))) +
#  geom_point() +
#  geom_smooth(method = "loess", se = FALSE) +
#  labs(x = "Fitted values", y = "Square root of standardized residuals") +
#  ggtitle("Scale-Location plot")



```

## All graphs

```{r graphs}


subset_dataFAnet <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                           moment == "jour" & Locality == "Koyli_Alpha" & Methode == "Net" & Superfamily %in% c("Formicoidea", "Apoidea"))


abundance_aggregatedFAnet <- aggregate(Abun_tree ~ id_tree + site + season+Superfamily, data = subset_dataFAnet, sum)

desired_order<-c("J","A","F")
abundance_aggregatedFAnet$season <- factor(abundance_aggregatedFAnet$season, levels = desired_order)

ggplot(abundance_aggregatedFAnet) + aes(x = Abun_tree, y = season, fill = season) + geom_boxplot() + scale_fill_brewer(palette = "Set1", direction = 1) + scale_x_continuous(trans = "log10") + labs(x = "Log10 Abundance / tree") + coord_flip() + theme_minimal() + theme( axis.title.y = element_text(size = 13L), axis.title.x = element_text(size = 13L), axis.text.y = element_text(size = 12L), axis.text.x = element_text(size = 12L), legend.text = element_text(size = 12L), legend.title = element_text(size = 12L) ) + facet_wrap(vars(Superfamily))

ggplot(abundance_aggregatedFAnet) +
  aes(x = Abun_tree, y = site, fill = Superfamily) +
  geom_boxplot() +
  scale_fill_hue(direction = -1) +
  scale_x_continuous(trans = "log1p") +
  labs(x = "Log1p abundance / tree") +
  coord_flip() +
  ggthemes::theme_base() +
  theme(
    axis.title.y = element_text(size = 13L),
    axis.title.x = element_text(size = 13L),
    axis.text.y = element_text(size = 12L),
    axis.text.x = element_text(size = 12L),
    legend.text = element_text(size = 11L),
    legend.title = element_text(size = 12L)
  ) +theme(axis.text.x = element_text(angle = 90L))+
  facet_wrap(vars(season))



subset_dataFApantrap <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Pantrap" & Superfamily %in% c("Formicoidea", "Apoidea"))

abundance_aggregatedFApantrap  <- aggregate(Abun_tree ~ id_tree + site + season+Superfamily, data = subset_dataFApantrap, sum)

desired_order<-c("J","A","F")
abundance_aggregatedFApantrap$season <- factor(abundance_aggregatedFApantrap$season, levels = desired_order)


ggplot(abundance_aggregatedFApantrap) + aes(x = Abun_tree, y = season, fill = season) + geom_boxplot() + scale_fill_brewer(palette = "Set1", direction = 1) + scale_x_continuous(trans = "log10") + labs(x = "Log10 Abundance / tree") + coord_flip() + theme_minimal() + theme( axis.title.y = element_text(size = 13L), axis.title.x = element_text(size = 13L), axis.text.y = element_text(size = 12L), axis.text.x = element_text(size = 12L), legend.text = element_text(size = 12L), legend.title = element_text(size = 12L) ) + facet_wrap(vars(Superfamily))



ggplot(abundance_aggregatedFApantrap) +
  aes(x = Abun_tree, y = site, fill = Superfamily) +
  geom_boxplot() +
  scale_fill_hue(direction = -1) +
  scale_x_continuous(trans = "log1p") +
  labs(x = "Log1p abundance / tree") +
  coord_flip() +
  ggthemes::theme_base() +
  theme(
    axis.title.y = element_text(size = 13L),
    axis.title.x = element_text(size = 13L),
    axis.text.y = element_text(size = 12L),
    axis.text.x = element_text(size = 12L),
    legend.text = element_text(size = 11L),
    legend.title = element_text(size = 12L)
  ) +theme(axis.text.x = element_text(angle = 90L))+
  facet_wrap(vars(season))


 
subset_dataordernet <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Net" & Order %in%c( "Hymenoptera","Diptera","Coleoptera","Hemiptera"))
  
abundance_aggregatedordernet <- aggregate(Abun_tree ~ id_tree + site + season+Order, data = subset_dataordernet , sum)
desired_order<-c("J","A","F")
abundance_aggregatedordernet$season <- factor(abundance_aggregatedordernet$season, levels = desired_order)
desiredorder<- c("Hymenoptera","Diptera","Hemiptera","Coleoptera")
abundance_aggregatedordernet$Order <- factor(abundance_aggregatedordernet$Order, levels = desiredorder)



ggplot(abundance_aggregatedordernet) + aes(x = Abun_tree, y = season, fill = season) + geom_boxplot() + scale_fill_brewer(palette = "Set1", direction = 1) + scale_x_continuous(trans = "log10") + labs(x = "Log10 Abundance / tree") + coord_flip() + theme_minimal() + theme( axis.title.y = element_text(size = 13L), axis.title.x = element_text(size = 13L), axis.text.y = element_text(size = 12L), axis.text.x = element_text(size = 12L), legend.text = element_text(size = 12L), legend.title = element_text(size = 12L) ) + facet_wrap(vars(Order))


ggplot(abundance_aggregatedordernet) +
  aes(x = Abun_tree, y = site, fill = Order) +
  geom_boxplot() +
  scale_fill_hue(direction = -1) +
  scale_x_continuous(trans = "log1p") +
  labs(x = "Log1p abundance / tree") +
  coord_flip() +
  ggthemes::theme_base() +
  theme(
    axis.title.y = element_text(size = 13L),
    axis.title.x = element_text(size = 13L),
    axis.text.y = element_text(size = 12L),
    axis.text.x = element_text(size = 12L),
    legend.text = element_text(size = 11L),
    legend.title = element_text(size = 12L)
  ) +theme(axis.text.x = element_text(angle = 90L))+
  facet_wrap(vars(season))

 
  
subset_dataorderpantrap<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Pantrap" & Order %in%c( "Hymenoptera","Diptera","Coleoptera","Hemiptera"))
  
abundance_aggregatedorderpantrap <- aggregate(Abun_tree ~ id_tree + site + season+Order, data = subset_dataorderpantrap, sum)

desired_order<-c("J","A","F")
abundance_aggregatedorderpantrap$season <- factor(abundance_aggregatedorderpantrap$season, levels = desired_order)

desiredorder<- c("Hymenoptera","Diptera","Hemiptera","Coleoptera")
abundance_aggregatedorderpantrap$Order <- factor(abundance_aggregatedorderpantrap$Order, levels = desiredorder)

ggplot(abundance_aggregatedorderpantrap) + aes(x = Abun_tree, y = season, fill = season) + geom_boxplot() + scale_fill_brewer(palette = "Set1", direction = 1) + scale_x_continuous(trans = "log10") + labs(x = "Log10 Abundance / tree") + coord_flip() + theme_minimal() + theme( axis.title.y = element_text(size = 13L), axis.title.x = element_text(size = 13L), axis.text.y = element_text(size = 12L), axis.text.x = element_text(size = 12L), legend.text = element_text(size = 12L), legend.title = element_text(size = 12L) ) + facet_wrap(vars(Order))

ggplot(abundance_aggregatedorderpantrap) +
  aes(x = Abun_tree, y = site, fill = Order) +
  geom_boxplot() +
  scale_fill_hue(direction = -1) +
  scale_x_continuous(trans = "log1p") +
  labs(x = "Log1p abundance / tree") +
  coord_flip() +
  ggthemes::theme_base() +
  theme(
    axis.title.y = element_text(size = 13L),
    axis.title.x = element_text(size = 13L),
    axis.text.y = element_text(size = 12L),
    axis.text.x = element_text(size = 12L),
    legend.text = element_text(size = 11L),
    legend.title = element_text(size = 12L)
  ) +theme(axis.text.x = element_text(angle = 90L))+
  facet_wrap(vars(season))





subset_datapantrap<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Pantrap")
  
abundance_aggregatedpantrap<- aggregate(Abun_tree ~ id_tree + site + season, data = subset_datapantrap, sum)

desired_order<-c("J","A","F")
abundance_aggregatedpantrap$season <- factor(abundance_aggregatedpantrap$season, levels = desired_order)

ggplot(abundance_aggregatedpantrap) +
  aes(x = Abun_tree, y = site, fill = site) +
  geom_boxplot() +
  scale_fill_manual(values = c("Depression" = "#1b9e77", "Unrestored" = "#d95f02", "Restored" = "#7570b3")) +
  scale_x_continuous(trans = "log10") +
  coord_flip() +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 13L),
    axis.text.x = element_text(size = 13L)
  ) +
  facet_wrap(vars(season))





subset_datanet<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" &  Methode == "Net")
  
abundance_aggregatednet <- aggregate(Abun_tree ~ id_tree + site + season, data = subset_datanet, sum)

desired_order<-c("J","A","F")
abundance_aggregatednet$season <- factor(abundance_aggregatednet$season, levels = desired_order)

ggplot(abundance_aggregatednet) +
  aes(x = Abun_tree, y = site, fill = site) +
  geom_boxplot() +
  scale_fill_manual(values = c("Depression" = "#1b9e77", "Unrestored" = "#d95f02", "Restored" = "#7570b3")) +
  scale_x_continuous(trans = "log10") +
  coord_flip() +
  theme_minimal() +
  theme(
    axis.text.y = element_text(size = 13L),
    axis.text.x = element_text(size = 13L)
  ) +
  facet_wrap(vars(season))

```

```{r lists}

subset_databracon <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Family=="Braconidae")
  
abundance_aggregatedbracon <- aggregate(Abun_tree ~  season, data = subset_databracon , sum)
desired_order<-c("J","A","F")
abundance_aggregatedbracon$season <- factor(abundance_aggregatedbracon$season, levels = desired_order)

subset_dataphorid<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Family=="Phoridae")
  
abundance_aggregatedphorid <- aggregate(Abun_tree ~ season, data = subset_dataphorid , sum)
desired_order<-c("J","A","F")
abundance_aggregatedphorid$season <- factor(abundance_aggregatedphorid$season, levels = desired_order)

subset_datamythic<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Family=="Mythicomyiidae")
  
abundance_aggregatedmythic <- aggregate(Abun_tree ~ season, data = subset_datamythic , sum)
desired_order<-c("J","A","F")
abundance_aggregatedmythic$season <- factor(abundance_aggregatedmythic$season, levels = desired_order)


subset_dataformic<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Family=="Formicidae")
  
abundance_aggregatedformic <- aggregate(Abun_tree ~ season, data = subset_dataformic , sum)
desired_order<-c("J","A","F")
abundance_aggregatedformic$season <- factor(abundance_aggregatedformic$season, levels = desired_order)



subset_datafseason<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Order %in%c( "Hymenoptera","Diptera","Coleoptera","Hemiptera"))
  
abundance_aggregatedfseason <- aggregate(Abun_tree ~ season+Family, data = subset_datafseason, sum)
desired_order<-c("J","A","F")
abundance_aggregatedfseason$season <- factor(abundance_aggregatedfseason$season, levels = desired_order)




subset_datafsite<- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour" & Locality == "Koyli_Alpha" & Order %in%c( "Hymenoptera","Diptera","Coleoptera","Hemiptera"))
  
abundance_aggregatedfsite <- aggregate(Abun_tree ~ season+Family+site+id_tree, data = subset_datafsite, sum)
desired_order<-c("J","A","F")
abundance_aggregatedfsite$season <- factor(abundance_aggregatedfsite$season, levels = desired_order)

#test for significant differences families, seasons and sites
test.2=glm.nb(Abun_tree ~id_tree+ season+Family, data = abundance_aggregatedfsite)
summary(test.2)
plot(simulateResiduals(test.2))

abundance_aggregatedfsite <- aggregate(Abun_tree ~ morphospecies+site+season, data = subset_datafsite, sum)
desired_order<-c("J","A","F")
abundance_aggregatedfsite$season <- factor(abundance_aggregatedfsite$season, levels = desired_order)




```

To save all the generated plots in the highest quality, you can use the `ggsave()` function in R. This function allows you to specify the filename, the plot object, and the desired dimensions and resolution for the saved image.

Here's the modified code to save each plot with high quality:

```{r graphs 2}
# Load necessary libraries
library(ggplot2)
library(ggthemes)

# Define the plots
plot1 <- ggplot(abundance_aggregatedFAnet) + 
  aes(x = Abun_tree, y = season, fill = season) + 
  geom_boxplot() + 
  scale_fill_brewer(palette = "Set1", direction = 1) + 
  scale_x_continuous(trans = "log10") + 
  labs(x = "Log10 Abundance / tree") + 
  coord_flip() + 
  theme_minimal() + 
  theme(axis.title.y = element_text(size = 13L), 
        axis.title.x = element_text(size = 13L), 
        axis.text.y = element_text(size = 12L), 
        axis.text.x = element_text(size = 12L), 
        legend.text = element_text(size = 12L), 
        legend.title = element_text(size = 12L)) + 
  facet_wrap(vars(Superfamily))

plot2 <- ggplot(abundance_aggregatedFAnet) +
  aes(x = Abun_tree, y = site, fill = Superfamily) +
  geom_boxplot() +
  scale_fill_hue(direction = -1) +
  scale_x_continuous(trans = "log1p") +
  labs(x = "Log1p abundance / tree") +
  coord_flip() +
  ggthemes::theme_base() +
  theme(axis.title.y = element_text(size = 13L),
        axis.title.x = element_text(size = 13L),
        axis.text.y = element_text(size = 12L),
        axis.text.x = element_text(size = 12L),
        legend.text = element_text(size = 11L),
        legend.title = element_text(size = 12L)) +
  theme(axis.text.x = element_text(angle = 90L)) +
  facet_wrap(vars(season))

plot3 <- ggplot(abundance_aggregatedFApantrap) + 
  aes(x = Abun_tree, y = season, fill = season) + 
  geom_boxplot() + 
  scale_fill_brewer(palette = "Set1", direction = 1) + 
  scale_x_continuous(trans = "log10") + 
  labs(x = "Log10 Abundance / tree") + 
  coord_flip() + 
  theme_minimal() + 
  theme(axis.title.y = element_text(size = 13L), 
        axis.title.x = element_text(size = 13L), 
        axis.text.y = element_text(size = 12L), 
        axis.text.x = element_text(size = 12L), 
        legend.text = element_text(size = 12L), 
        legend.title = element_text(size = 12L)) + 
  facet_wrap(vars(Superfamily))

plot4 <- ggplot(abundance_aggregatedFApantrap) +
  aes(x = Abun_tree, y = site, fill = Superfamily) +
  geom_boxplot() +
  scale_fill_hue(direction = -1) +
  scale_x_continuous(trans = "log1p") +
  labs(x = "Log1p abundance / tree") +
  coord_flip() +
  ggthemes::theme_base() +
  theme(axis.title.y = element_text(size = 13L),
        axis.title.x = element_text(size = 13L),
        axis.text.y = element_text(size = 12L),
        axis.text.x = element_text(size = 12L),
        legend.text = element_text(size = 11L),
        legend.title = element_text(size = 12L)) +
  theme(axis.text.x = element_text(angle = 90L)) +
  facet_wrap(vars(season))

plot5 <- ggplot(abundance_aggregatedordernet) + 
  aes(x = Abun_tree, y = season, fill = season) + 
  geom_boxplot() + 
  scale_fill_brewer(palette = "Set1", direction = 1) + 
  scale_x_continuous(trans = "log10") + 
  labs(x = "Log10 Abundance / tree") + 
  coord_flip() + 
  theme_minimal() + 
  theme(axis.title.y = element_text(size = 13L), 
        axis.title.x = element_text(size = 13L), 
        axis.text.y = element_text(size = 12L), 
        axis.text.x = element_text(size = 12L), 
        legend.text = element_text(size = 12L), 
        legend.title = element_text(size = 12L)) + 
  facet_wrap(vars(Order))

plot6 <- ggplot(abundance_aggregatedordernet) +
  aes(x = Abun_tree, y = site, fill = Order) +
  geom_boxplot() +
  scale_fill_hue(direction = -1) +
  scale_x_continuous(trans = "log1p") +
  labs(x = "Log1p abundance / tree") +
  coord_flip() +
  ggthemes::theme_base() +
  theme(axis.title.y = element_text(size = 13L),
        axis.title.x = element_text(size = 13L),
        axis.text.y = element_text(size = 12L),
        axis.text.x = element_text(size = 12L),
        legend.text = element_text(size = 11L),
        legend.title = element_text(size = 12L)) +
  theme(axis.text.x = element_text(angle = 90L)) +
  facet_wrap(vars(season))

plot7 <- ggplot(abundance_aggregatedorderpantrap) + 
  aes(x = Abun_tree, y = season, fill = season) + 
  geom_boxplot() + 
  scale_fill_brewer(palette = "Set1", direction = 1) + 
  scale_x_continuous(trans = "log10") + 
  labs(x = "Log10 Abundance / tree") + 
  coord_flip() + 
  theme_minimal() + 
  theme(axis.title.y = element_text(size = 13L), 
        axis.title.x = element_text(size = 13L), 
        axis.text.y = element_text(size = 12L), 
        axis.text.x = element_text(size = 12L), 
        legend.text = element_text(size = 12L), 
        legend.title = element_text(size = 12L)) + 
  facet_wrap(vars(Order))

plot8 <- ggplot(abundance_aggregatedorderpantrap) +
  aes(x = Abun_tree, y = site, fill = Order) +
  geom_boxplot() +
  scale_fill_hue(direction = -1) +
  scale_x_continuous(trans = "log1p") +
  labs(x = "Log1p abundance / tree") +
  coord_flip() +
  ggthemes::theme_base() +
  theme(axis.title.y = element_text(size = 13L),
        axis.title.x = element_text(size = 13L),
        axis.text.y = element_text(size = 12L),
        axis.text.x = element_text(size = 12L),
        legend.text = element_text(size = 11L),
        legend.title = element_text(size = 12L)) +
  theme(axis.text.x = element_text(angle = 90L)) +
  facet_wrap(vars(season))

# Save plots with high quality
ggsave("plot1.png", plot = plot1, width = 10, height = 8, dpi = 300)
ggsave("plot2.png", plot = plot2, width = 10, height = 8, dpi = 300)
ggsave("plot3.png", plot = plot3, width = 10, height = 8, dpi = 300)
ggsave("plot4.png", plot = plot4, width = 10, height = 8, dpi = 300)
ggsave("plot5.png", plot = plot5, width = 10, height = 8, dpi = 300)
ggsave("plot6.png", plot = plot6, width = 10, height = 8, dpi = 300)
ggsave("plot7.png", plot = plot7, width = 10, height = 8, dpi = 300)
ggsave("plot8.png", plot = plot8, width = 10, height = 8, dpi = 300)
#This code will save each plot as a high-quality PNG file with a resolution of 300 DPI. You can adjust the `width`, `height`, and `dpi` parameters as needed to suit your requirements.


```

# Bees Networks

```{r bees networks june}

subset_data_K_n <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha")

abundance_aggregated_n<-aggregate(Abun_tree ~ morphospecies+id_tree+site+season+Order+functional_group+Family, data = subset_data_K_n, sum)


#In order to change the level of filtering don't forget to modify here the selection_ 
abundance_aggregated_n<-abundance_aggregated_n%>%filter(Order %in% c("Hymenoptera", "Diptera"
  ))%>%filter(season %in% ("J") )%>%filter(functional_group %in% ("pollinator_hymenoptera") )
###Matrix per treatment

UniMorpho <- unique(abundance_aggregated_n$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_n$site)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_n$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_nt<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_nt) <- UniMorpho
colnames(Abu_K_nt) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_n$site == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_n$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_n$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_nt[i, j] <- Abui
  }
}

```

```{r bees network treatment - with sankey june}
# Reorder the columns of your data frame to match the desired order


Abu_K_nt<-as.data.frame(Abu_K_nt)

# I need a long format
data_long <- Abu_K_nt %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")


# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", 
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey","grey","grey","grey","grey","grey","grey","grey","#26A69A","#FF5722","#CDDC39"])'
# Make the Network
sn<-sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=8, fontSize=15, nodePadding=1)


sn

# you save it as an html
saveNetwork(sn, "sn_Jallbees.html")

# you convert it as png
webshot("sn_Jallbees.html","sn_Jallbees.png", vwidth = 1500, vheight = 1100)

#data_long <- data_long %>% arrange(desc(value))


```

```{r bees networks august}

subset_data_K_n <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha")

abundance_aggregated_n<-aggregate(Abun_tree ~ morphospecies+id_tree+site+season+Order+functional_group+Family, data = subset_data_K_n, sum)


#In order to change the level of filtering don't forget to modify here the selection_ 
abundance_aggregated_n<-abundance_aggregated_n%>%filter(Order %in% c("Hymenoptera", "Diptera"
  ))%>%filter(season %in% ("A") )%>%filter(functional_group %in% ("pollinator_hymenoptera") )
###Matrix per treatment

UniMorpho <- unique(abundance_aggregated_n$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_n$site)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_n$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_nt<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_nt) <- UniMorpho
colnames(Abu_K_nt) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_n$site == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_n$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_n$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_nt[i, j] <- Abui
  }
}

```

```{r bees network treatment - with sankey august}
# Reorder the columns of your data frame to match the desired order


Abu_K_nt<-as.data.frame(Abu_K_nt)

# I need a long format
data_long <- Abu_K_nt %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")


# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", 
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey","grey","grey","grey","grey","grey","grey","grey","#26A69A","#FF5722","#CDDC39"])'
# Make the Network
sn<-sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=8, fontSize=15, nodePadding=1)


sn

# you save it as an html
saveNetwork(sn, "sn_Aallbees.html")

# you convert it as png
webshot("sn_Aallbees.html","sn_Aallbees.png", vwidth = 1500, vheight = 1100)

#data_long <- data_long %>% arrange(desc(value))


```

```{r bees networks february}

subset_data_K_n <- subset(dfs_lists_VB$Balanites_aegyptiaca,
                        moment == "jour"& Locality == "Koyli_Alpha")

abundance_aggregated_n<-aggregate(Abun_tree ~ morphospecies+id_tree+site+season+Order+functional_group+Family, data = subset_data_K_n, sum)


#In order to change the level of filtering don't forget to modify here the selection_ 
abundance_aggregated_n<-abundance_aggregated_n%>%filter(Order %in% c("Hymenoptera", "Diptera"
  ))%>%filter(season %in% ("F") )%>%filter(functional_group %in% ("pollinator_hymenoptera") )
###Matrix per treatment

UniMorpho <- unique(abundance_aggregated_n$morphospecies)#choix de la morphoespèce unique
uniloc    <- unique(abundance_aggregated_n$site)#cette variable reste a changer en fonction du tableau utilisé

# Create a matrix Locs filled with zeros
# Locs crée une variable avec toutes les morphoespeces en ligne et les colonnes uniques (en fonction du choix fait)
Locs <- matrix(0, nrow = length(abundance_aggregated_n$morphospecies), ncol = length(uniloc))


#Abu = matrice vide pour info unique de morphoespece et de uniloc(qui varie en fonction de la question)
Abu_K_nt<- matrix(0, nrow = length(UniMorpho), ncol = length(uniloc))              
rownames(Abu_K_nt) <- UniMorpho
colnames(Abu_K_nt) <- uniloc


# Loop through each element of uniloc
for (i in seq_along(uniloc)) {
  # Set the corresponding column in Locs to 1 where the condition is true, result of the matrix presence/absence
  Locs[, i] <- abundance_aggregated_n$site == uniloc[i]
}                                   

# Loop through each element of UniMorpho
for (i in seq_along(UniMorpho)) {
  # Create a logical vector Wh1 based on the condition
  #binary condition (presence 1 abs 0)
  Wh1 <- abundance_aggregated_n$morphospecies == UniMorpho[i]
  
  # Loop through each element of uniloc
  for (j in seq_along(uniloc)) {
    # Use which to get indices where the condition is true
    A <- which(Wh1 * Locs[, j]!=0)
    
    # Sum the corresponding Abun_tree values
    Abui <- sum(abundance_aggregated_n$Abun_tree[A])
    
    # Assign the sum to Locs[i, j],nouvelle matrice avec la somme des toutes les abondances par colonne
    Abu_K_nt[i, j] <- Abui
  }
}

```

```{r bees network treatment - with sankey february}
# Reorder the columns of your data frame to match the desired order


Abu_K_nt<-as.data.frame(Abu_K_nt)

# I need a long format
data_long <- Abu_K_nt %>%
  rownames_to_column %>%
  gather(key = 'key', value = 'value', -rowname) %>%
  filter(value > 0)
colnames(data_long) <- c("source", "target", "value")
data_long$target <- paste(data_long$target, " ", sep="")


# From these flows we need to create a node data frame: it lists every entities involved in the flow
nodes <- data.frame(name=c(as.character(data_long$source), as.character(data_long$target)) %>% unique())

# With networkD3, connection must be provided using id, not using real name like in the links dataframe.. So we need to reformat it.
data_long$IDsource=match(data_long$source, nodes$name)-1 
data_long$IDtarget=match(data_long$target, nodes$name)-1

my_color <- 'd3.scaleOrdinal().range(["grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", 
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey", "grey",
"grey","grey","grey","grey","grey","grey","grey","grey","#26A69A","#FF5722","#CDDC39"])'
# Make the Network
sn<-sankeyNetwork(Links = data_long, Nodes = nodes,
              Source = "IDsource", Target = "IDtarget",
              Value = "value", NodeID = "name", 
              sinksRight=FALSE, colourScale=my_color, nodeWidth=8, fontSize=15, nodePadding=1)


sn

# you save it as an html
saveNetwork(sn, "sn_Fallbees.html")

# you convert it as png
webshot("sn_Fallbees.html","sn_Fallbees.png", vwidth = 1500, vheight = 1100)

#data_long <- data_long %>% arrange(desc(value))


```
